diff --git a/app.c b/app.c
index d8c6d65..f70eb24 100644
--- a/app.c
+++ b/app.c
@@ -29,6 +29,7 @@
 #include "configuration.h"
 #include "definitions.h"
 #include "app.h"
+#include "wm8904.h"
 
 
 #define debug_log(...) printf(__VA_ARGS__) 
@@ -36,12 +37,27 @@
 
 #define APP_ID_FEATURE_UNIT    0x05
 #define APP_QUEUING_DEPTH  2  
-#define APP_PERIOD_SIZE (96*2*2)  //must be multi size of max endpoint
+#define APP_REC_QUEUING_DEPTH  5  
 
+
+#ifdef USB_AUDIO_FEEDUP_ENABLE
+	#define	APP_PERIOD_SIZE USB_MAX_RX_SIZE
+#else 
+	#define APP_PERIOD_SIZE (48*2*2)  //must be multi size of max endpoint, itherwise submit URB will faild 
+#endif
+
+
+
+#define APP_DEFAULT_SAMPLE_FREQ 48000
 // the I2S TX data register must +2 at 16 bit width mode
 #define I2S_DEST 0x43002832
+#define I2S_RX_REG 0x43002836
+
 #define DMA_BUF_LEN (32*1024)
 
+#define UNDERRUN_LEVEL (APP_PERIOD_SIZE/2)
+
+
 
 typedef struct
 {
@@ -54,6 +70,7 @@ typedef struct
     /* device configured state */
     bool isConfigured;
     uint32_t usbInterface;
+	uint32_t usbInterface_alt;
     // uint32_t activeMicInterfaceAlternateSetting;
 
      uint32_t sampleFreq;
@@ -62,7 +79,11 @@ typedef struct
 	volatile unsigned char dmaBuffState;
     uint32_t peroidSize;
     uint8_t dmaBeatSize;
+	uint8_t feedState;
+	uint32_t feedFreq;
+	uint32_t dmaFreeSize;
 	uint32_t sof;
+	
 
     bool volMuteMode;
 	unsigned int playWritePt;
@@ -75,7 +96,8 @@ typedef struct
 {
     uint8_t  isUsed;               //Next Buffer for Codec TX
     uint8_t  isDataReady;                  //Next Buffer for USB RX 
-    
+    uint32_t dataLen;
+	unsigned char *buf;
     USB_DEVICE_AUDIO_TRANSFER_HANDLE usbReadHandle;
 } APP_PLAYBACK_BUFFER_QUEUE;
 
@@ -88,21 +110,34 @@ APP_DATA appData = {
 };
 
 
-
-
-
 unsigned char dma_buff[DMA_BUF_LEN] __ALIGNED(4);  // 8K frames for 16bit stero 
 unsigned char usb_buf1[APP_PERIOD_SIZE] __ALIGNED(32);
 unsigned char usb_buf2[APP_PERIOD_SIZE] __ALIGNED(32);
 
+unsigned char usb_buf_rec1[RECORD_PERIOD_SIZE] __ALIGNED(32);
+unsigned char usb_buf_rec2[RECORD_PERIOD_SIZE] __ALIGNED(32);
+unsigned char usb_buf_rec3[RECORD_PERIOD_SIZE] __ALIGNED(32);
+unsigned char usb_buf_rec4[RECORD_PERIOD_SIZE] __ALIGNED(32);
+unsigned char usb_buf_rec5[RECORD_PERIOD_SIZE] __ALIGNED(32);
+
+
 
-APP_PLAYBACK_BUFFER_QUEUE  buf_queue[APP_QUEUING_DEPTH];
 
 
+unsigned char usb_buf_feed[4] __ALIGNED(32);
 
 
 
+APP_PLAYBACK_BUFFER_QUEUE  buf_queue[APP_QUEUING_DEPTH];
+APP_PLAYBACK_BUFFER_QUEUE  rec_buf_queue[APP_REC_QUEUING_DEPTH+1];
+
+
+#ifdef FEED_DEBUG
+	unsigned short debug_buf[256];
+unsigned int  uart_wr = 0;
+unsigned int  uart_rd = 0;
 
+#endif
 
 
 
@@ -111,7 +146,7 @@ void send_read_request(void)
 {
     unsigned int i;
     USB_DEVICE_AUDIO_RESULT ret;
-    USB_DEVICE_AUDIO_TRANSFER_HANDLE usbReadHandle;
+//    USB_DEVICE_AUDIO_TRANSFER_HANDLE usbReadHandle;
     
     for(i=0;i<APP_QUEUING_DEPTH;i++){
         if(!buf_queue[i].isUsed){
@@ -137,6 +172,94 @@ void send_read_request(void)
     }
 }
 
+
+								
+#define FEED_SLOW_STATE 1
+#define FEED_FAST_STATE 2
+#define FEED_NORMAL_STATE 0
+
+#define FEED_MIN_VALUE (APP_DEFAULT_SAMPLE_FREQ - APP_DEFAULT_SAMPLE_FREQ/8)
+#define FEED_MAX_VALUE (APP_DEFAULT_SAMPLE_FREQ + APP_DEFAULT_SAMPLE_FREQ/4)
+
+#define FAST_FEED_STEP    60 //20000  // (sizeof(IsocOutBuff)/2 /(USBD_AUDIO_FREQ/4) ) 
+#define SLOW_FEED_STEP  60 //20000 // (sizeof(IsocOutBuff)/2 /(USBD_AUDIO_FREQ/8) ) 
+
+
+#define FEED_FREQ_2_BUFF(buf,freq) ( *(uint32_t *)buf = ( ( ((uint32_t) freq /1000) << 14) | ((freq %1000) << 4) )  )
+
+#define FEED_2_FREQ(freq) (  (freq)  << 2 & 0xff00 |   (freq)  & 0xff )
+
+
+
+
+void send_feed(uint32_t freeSize)
+{
+	USB_DEVICE_AUDIO_TRANSFER_HANDLE handle;
+	USB_DEVICE_AUDIO_RESULT ret;
+
+
+#ifdef	FEED_DEBUG
+	debug_buf[uart_wr] = freeSize;
+	uart_wr++;
+	if(uart_wr >= 256)
+		uart_wr = 0;
+
+#endif
+
+
+	switch(appData.feedState){
+
+		case FEED_NORMAL_STATE:
+			appData.feedFreq = APP_DEFAULT_SAMPLE_FREQ;
+			if(freeSize >= DMA_BUF_LEN*3/4){
+				//printf("fast\r\n");
+				appData.feedState = FEED_FAST_STATE;
+			}
+			else if(freeSize <= DMA_BUF_LEN/4){
+				//printf("slow\r\n");
+				appData.feedState = FEED_SLOW_STATE;
+			}
+			break;
+		case FEED_SLOW_STATE:
+			appData.feedFreq -= SLOW_FEED_STEP; 
+			if(appData.feedFreq <= FEED_MIN_VALUE) {
+				appData.feedFreq = FEED_MIN_VALUE;
+			}		
+
+			// the threshold should be < DMA_BUF_LEN*3/4, 
+			// otherwise feedState would switched to FEED_FAST_STATE after goto FEED_NORMAL_STATE
+			if(freeSize >= DMA_BUF_LEN*3/5)  
+				appData.feedState = FEED_NORMAL_STATE;
+				
+			break;
+		case FEED_FAST_STATE:
+			appData.feedFreq += SLOW_FEED_STEP; 
+			if(appData.feedFreq >= FEED_MAX_VALUE) {
+				appData.feedFreq = FEED_MAX_VALUE;
+			}
+			// to avoid too much data buffered in DMA, the free size should not be too small
+			if(freeSize <= DMA_BUF_LEN/2)
+				appData.feedState = FEED_NORMAL_STATE;
+			
+			break;		
+		default :
+			appData.feedFreq = APP_DEFAULT_SAMPLE_FREQ;
+			break;
+	};
+
+
+	FEED_FREQ_2_BUFF(usb_buf_feed,appData.feedFreq);
+	
+	ret = USB_DEVICE_AUDIO_Write(USB_DEVICE_INDEX_0, &handle, 1, usb_buf_feed, 3);
+	
+	if(ret != USB_DEVICE_AUDIO_RESULT_OK){
+		//debug_log("send_feed error %d\r\n",ret);
+
+	}		   
+
+
+}
+
 int isAllBuffQueueReady(void)
 {
     unsigned int i;
@@ -153,12 +276,42 @@ int isAllBuffQueueReady(void)
  {
 	 unsigned int i;
 	 
-	 for(i=0;i<APP_QUEUING_DEPTH;i++){
-		 buf_queue[i].isDataReady = 0;
-		 buf_queue[i].isUsed = 0;
+	 //for(i=0;i<APP_QUEUING_DEPTH;i++){
+	//	 buf_queue[i].isDataReady = 0;
+	//	 buf_queue[i].isUsed = 0;
+
+	 //}
+
+	 memset(buf_queue,0,sizeof(buf_queue));
+
+ }
+ void ClearRecBuffQueue(void)
+ {
+	 unsigned int i;
+	 
+	 for(i=0;i<APP_REC_QUEUING_DEPTH;i++){
+		 rec_buf_queue[i].isDataReady = 0;
+		 rec_buf_queue[i].isUsed = 0;
 
 	 }
 
+
+ }
+ void InitRecBuffQueue(void)
+ {
+	 unsigned int i;
+	 
+	 for(i=0;i<APP_REC_QUEUING_DEPTH;i++){
+		 rec_buf_queue[i].isDataReady = 0;
+		 rec_buf_queue[i].isUsed = 0;
+
+	 }
+	rec_buf_queue[0].buf = usb_buf_rec1;
+	 rec_buf_queue[1].buf = usb_buf_rec2;
+	 rec_buf_queue[2].buf = usb_buf_rec3;
+	 rec_buf_queue[3].buf = usb_buf_rec4;
+	 rec_buf_queue[4].buf = usb_buf_rec5;
+
  }
 
 
@@ -183,12 +336,32 @@ int isAllBuffQueueReady(void)
 }
 
 
-#define UNDERRUN_LEVEL (APP_PERIOD_SIZE/2)
-void copy2dma_buff(unsigned char *buf,unsigned int len)
+ void stop_i2s_rx(void )
+{
+	unsigned int reg = I2S_REGS->I2S_CTRLA;
+
+	reg &= ~(1 << 5);
+
+	I2S_REGS->I2S_CTRLA = reg;
+	
+}
+
+ void start_i2s_rx(void )
+{
+	unsigned int reg = I2S_REGS->I2S_CTRLA;
+
+	reg |= (1 << 5);
+
+	I2S_REGS->I2S_CTRLA = reg;
+	
+}
+
+
+uint32_t copy2dma_buff(unsigned char *buf,unsigned int len)
 {
     unsigned int writePt;
     unsigned int readPt;
-    unsigned int cnt,free_size,gap;
+    unsigned int free_size,gap;
 	//static unsigned char dmaBuffState = PLAY_DMA_BUF_NORMAL;
     
     readPt = appData.dmaBeatSize * DMAC_ChannelGetTransferredCount(DMAC_CHANNEL_1);
@@ -213,8 +386,8 @@ void copy2dma_buff(unsigned char *buf,unsigned int len)
     }
 
     if(free_size <= len){  
-        debug_log("over run, readPt 0x%x, writePt 0x%x\r\n",readPt,writePt);
-        return;
+        debug_log("over run, free %d, feed %d\r\n",free_size,(appData.feedFreq));
+        return 0;
     }
 
     else{// buff is enough
@@ -263,7 +436,7 @@ void copy2dma_buff(unsigned char *buf,unsigned int len)
 
     }
 
-        
+    return free_size; 
 }
 
 
@@ -272,22 +445,22 @@ int isUnderRun(void )
 
     unsigned int writePt = appData.playWritePt;
     unsigned int readPt;
-    unsigned int cnt,free_size,gap;
+    unsigned int gap;
 	//static unsigned char dmaBuffState = PLAY_DMA_BUF_NORMAL;
     
     readPt = appData.dmaBeatSize * DMAC_ChannelGetTransferredCount(DMAC_CHANNEL_1);
     
 
     if(writePt > readPt){
-        free_size = DMA_BUF_LEN - writePt + readPt;
+        ///free_size = DMA_BUF_LEN - writePt + readPt;
         gap = writePt - readPt;
     }
 	else if(writePt == readPt){
-		free_size = DMA_BUF_LEN;
+		//free_size = DMA_BUF_LEN;
 		gap = DMA_BUF_LEN;
 	}
     else{
-        free_size = readPt - writePt;
+        //free_size = readPt - writePt;
         gap = DMA_BUF_LEN - writePt + readPt;
     }
 
@@ -303,7 +476,7 @@ void process_read_data(void )
 {
     int i;
     USB_DEVICE_AUDIO_RESULT ret;
-	static unsigned int rx_cnt = 0;
+	static unsigned int timer = 0;
 
 
 	// printf("dma pt 0x%x\r\n",DMAC_ChannelGetTransferredCount(DMAC_CHANNEL_1));
@@ -312,7 +485,7 @@ void process_read_data(void )
         if(buf_queue[i].isDataReady){
 
             
-            copy2dma_buff(appData.usb_buf[i],APP_PERIOD_SIZE);
+            appData.dmaFreeSize = copy2dma_buff(appData.usb_buf[i],buf_queue[i].dataLen);
             
             ret = USB_DEVICE_AUDIO_Read(USB_DEVICE_INDEX_0, 
                           &buf_queue[i].usbReadHandle, 
@@ -328,13 +501,60 @@ void process_read_data(void )
                 buf_queue[i].isDataReady = 0;
             }
 			
-			if((rx_cnt % 250) == 0)
-				printf("rx cnt %d\r\n",rx_cnt);
-			rx_cnt++;
+			//if((rx_cnt % 250) == 0)
+			//	printf("rx cnt %d\r\n",rx_cnt);
+			//rx_cnt++;
         }
     }   
+
+#ifdef USB_AUDIO_FEEDUP_ENABLE
+
+	//appData.sampleFreq = APP_DEFAULT_SAMPLE_FREQ;
+
+	if(SYSTICK_msPeriodGet(timer) >= 6) { // host will read feed data per 8ms
+		send_feed(appData.dmaFreeSize);
+		timer = SYSTICK_msCounter();
+	}
+
+#endif
+
+}
+
+int find_valide_rec_buff()
+{
+	int i;
+	
+	for(i=0;i<APP_REC_QUEUING_DEPTH;i++){
+
+		if(!rec_buf_queue[i].isDataReady){
+			return i;
+		}
+
+
+	}
+	return -1;
 }
 
+void process_record()
+{
+
+	int i;
+	USB_DEVICE_AUDIO_RESULT ret;
+	
+	for(i=0;i<APP_REC_QUEUING_DEPTH;i++){
+
+		if(rec_buf_queue[i].isDataReady){
+			ret = USB_DEVICE_AUDIO_Write(USB_DEVICE_INDEX_0, 
+							  &buf_queue[i].usbReadHandle, 
+							  1, rec_buf_queue[i].buf, 
+							  RECORD_PERIOD_SIZE);			
+		}
+
+
+	}	 
+
+
+}
 void dma_callback(DMAC_TRANSFER_EVENT status, uintptr_t context) {
 
 	static unsigned int dma_cnt = 0;
@@ -344,20 +564,47 @@ void dma_callback(DMAC_TRANSFER_EVENT status, uintptr_t context) {
 	//	debug_log("dma triggle %d\r\n",dma_cnt);
 }
 
+void dma_callback_record(DMAC_TRANSFER_EVENT status, uintptr_t context)
+{
+	int index;
+	static unsigned int dma_cnt = 0;
+	
+	index = find_valide_rec_buff();
+	if(index == -1){
+		index = APP_REC_QUEUING_DEPTH ; //reserver last buff for overrun
+		debug_log("rec over\r\n");
+
+	}
+
+	rec_buf_queue[index].isDataReady = 0;
+    DMAC_ChannelTransfer(DMAC_CHANNEL_0,(void *)I2S_RX_REG, (void *) rec_buf_queue[index].buf,RECORD_PERIOD_SIZE);
+
+
+	
+	if(dma_cnt % 500 == 0)
+		printf("dma_cnt %d\r\n",dma_cnt);
+
+	dma_cnt++;
+}
+
+
 
-int wait_dma_buff_sync()
+void  wait_dma_buff_sync()
 {
 
     unsigned int writePt = appData.playWritePt;
-    unsigned int readPt,start,timer;
-    unsigned int cnt,free_size,gap;
-	int delay;
+    unsigned int readPt,start;
+    unsigned int gap;
+	unsigned int delay,time_out;
 	//static unsigned char dmaBuffState = PLAY_DMA_BUF_NORMAL;
 
 
 	start = SYSTICK_msCounter();
 	delay = 0;
 
+	// the audio data buffered less than DMA_BUF_LEN/2
+	time_out = 1000 / (APP_DEFAULT_SAMPLE_FREQ / (DMA_BUF_LEN/4) ) / 2;
+
 	do{
 	    readPt = appData.dmaBeatSize * DMAC_ChannelGetTransferredCount(DMAC_CHANNEL_1);
 	    
@@ -372,10 +619,10 @@ int wait_dma_buff_sync()
 	        gap = DMA_BUF_LEN - writePt + readPt;
 	    }
 
-		timer = SYSTICK_msCounter();
-		delay = SYSTICK_msPeriodGet(start);// delay must <=10ms
+		//timer = SYSTICK_msCounter();
+		delay = SYSTICK_msPeriodGet(start);// delay must <=5ms
 
-	}while(gap >= UNDERRUN_LEVEL/2 && delay < 5);
+	}while(gap >= UNDERRUN_LEVEL/2 && delay < time_out);
 
 
 
@@ -389,6 +636,7 @@ void start_player(void)
 	DMAC_ChannelCallbackRegister(DMAC_CHANNEL_1, dma_callback, 0);
 	DMAC_ChannelTransfer(DMAC_CHANNEL_1,(void *) &dma_buff[0],(void *)I2S_DEST ,sizeof(dma_buff));
 	start_i2s_tx();
+	wm8904_hpout_mute(CODEC_HPOUT_MUTE_OFF);
 	
 	
 	debug_log("playing\r\n");
@@ -400,25 +648,98 @@ void stop_play()
 	
 	wait_dma_buff_sync();
 	stop_i2s_tx();
+	wm8904_hpout_mute(CODEC_HPOUT_MUTE_ON);
 	DMAC_ChannelDisable(DMAC_CHANNEL_1);
 	ClearBuffQueue();
+	// no need to cancle all URB, device layer will cancle all URB when inferface is changed to 0
 
 	appData.playWritePt = 0;
 	appData.dmaBuffState = PLAY_DMA_BUF_NORMAL;
 
-	debug_log("stoping play\r\n");
+	debug_log("stopping play\r\n");
 }
 
+void start_record()
+{
+	ClearRecBuffQueue();
+
+	DMAC_ChannelCallbackRegister(DMAC_CHANNEL_0, dma_callback_record, 0);
+	DMAC_ChannelTransfer(DMAC_CHANNEL_0,(void *)I2S_RX_REG ,(void *) rec_buf_queue[0].buf,RECORD_PERIOD_SIZE);
+	start_i2s_rx();	
+}
+
+void stop_record()
+{
+	stop_i2s_rx();	
+	DMAC_ChannelDisable(DMAC_CHANNEL_0);
+}
+
+void APP_RecordTasks()
+{
+	static int state = APP_RECORD_INIT;
+	switch(state){
+		case APP_RECORD_INIT:
+			InitRecBuffQueue();
+			state = APP_RECORD_START_CHECK;
+			break;
+	
+		case APP_RECORD_START_CHECK :
+			if(appData.isConfigured == 1 && \
+				appData.usbInterface == USB_AUDIO_INTERFACE_CAPTURE && \
+				appData.usbInterface_alt == 1){
+
+				state = APP_RECORDING;
+
+				start_record();
+				debug_log("recording\r\n");
+			}
+
+
+				
+		break;
+		case APP_RECORDING:
+			if(appData.isConfigured == 1 && \
+				appData.usbInterface == USB_AUDIO_INTERFACE_CAPTURE && \
+				appData.usbInterface_alt == 0){
+				
+				state = APP_RECORD_START_CHECK;
+				
+				stop_record();
+				debug_log("record  stopping\r\n");
+
+				break;
+			
+			
+			}
+			process_record();
+
+
+		
+		break;
+		
+		default :
+		break;
+
+	};
+}
 
 void APP_Initialize ( void )
 {
 
 }
-void APP_Tasks ( void )
+
+
+void APP_PlayTasks ( void )
 {  
-    USB_DEVICE_AUDIO_TRANSFER_HANDLE usbReadHandle;
-    USB_DEVICE_AUDIO_RESULT ret;
-    unsigned int i;
+#ifdef FEED_DEBUG
+		if(uart_wr	!= uart_rd){
+			printf("%d\r\n",debug_buf[uart_rd]);
+			uart_rd++;
+			if(uart_rd >= 256)
+				uart_rd = 0 ;
+		}
+#endif
+
             
     switch(appData.state){
         case APP_STATE_INIT :
@@ -427,18 +748,30 @@ void APP_Tasks ( void )
 			appData.usb_buf[0] = usb_buf1;
 			appData.usb_buf[1] = usb_buf2;
             appData.peroidSize = APP_PERIOD_SIZE;
-			appData.dmaBeatSize = 2;			
+			appData.dmaBeatSize = 2;	
+			appData.sampleFreq = APP_DEFAULT_SAMPLE_FREQ;
 			
 		break;
 		case APP_STATE_USB_CONFIGURED :
-            if(appData.isConfigured == 1 && appData.usbInterface == USB_AUDIO_INTERFACE_PLAYING){
+            if(appData.isConfigured == 1 && \
+				appData.usbInterface == USB_AUDIO_INTERFACE_PLAYING && \
+				appData.usbInterface_alt == 1){
                 appData.state = APP_STATE_USB_INIT_READ;
-
+				appData.feedState = FEED_NORMAL_STATE;
+				appData.feedFreq = APP_DEFAULT_SAMPLE_FREQ;
+				appData.dmaFreeSize = DMA_BUF_LEN/2;
+				ClearBuffQueue();
                 send_read_request();
-            }
+			
+            }		
             break;
         case APP_STATE_USB_INIT_READ :
             // wait for all buff queue data ready, then start player
+            if(appData.usbInterface == USB_AUDIO_INTERFACE_PLAYING && appData.usbInterface_alt == 0){
+				// if host change inferce very fast, we change state to wait APP_STATE_USB_CONFIGURED
+				appData.state = APP_STATE_USB_CONFIGURED;
+				break;
+			}
             if(isAllBuffQueueReady()){
                 appData.state = APP_STATE_PLAYING;
 				appData.playWritePt = APP_QUEUING_DEPTH*APP_PERIOD_SIZE;
@@ -446,10 +779,11 @@ void APP_Tasks ( void )
 				send_read_request();
                 start_player();
             }
+			
             break;
         case APP_STATE_PLAYING :
 
-			if(appData.usbInterface == USB_AUDIO_INTERFACE_NON){
+			if(appData.usbInterface == USB_AUDIO_INTERFACE_PLAYING && appData.usbInterface_alt == 0){
 
 				stop_play();
 				appData.state = APP_STATE_USB_CONFIGURED;
@@ -457,9 +791,10 @@ void APP_Tasks ( void )
 				//stop_i2s_tx();
 				//debug_log("pausing play\r\n");
 			}
-			else if(appData.usbInterface == USB_AUDIO_INTERFACE_PLAYING)
+			else if(appData.usbInterface == USB_AUDIO_INTERFACE_PLAYING){
             	process_read_data();
-			else{}
+			}
+
 			break;
 			
 		default :
@@ -469,7 +804,19 @@ void APP_Tasks ( void )
 
 }
 
-static void APP_SetUSBReadBufferReady(USB_DEVICE_AUDIO_TRANSFER_HANDLE handle)
+void APP_Tasks()
+{
+
+	APP_PlayTasks();
+#ifdef AUDIO_IN_ENABLE
+
+	APP_RecordTasks();
+
+#endif
+
+}
+
+static void APP_SetUSBReadBufferReady(USB_DEVICE_AUDIO_TRANSFER_HANDLE handle,uint32_t len)
 {
     int i=0;
     for (i=0; i<APP_QUEUING_DEPTH; i++)
@@ -478,6 +825,23 @@ static void APP_SetUSBReadBufferReady(USB_DEVICE_AUDIO_TRANSFER_HANDLE handle)
         {
             buf_queue[i].isDataReady = 1;
 			buf_queue[i].isUsed = 0;
+			buf_queue[i].dataLen = len;
+            break;
+        }
+    }
+}
+
+
+static void APP_SetUSBWrBufferReady(USB_DEVICE_AUDIO_TRANSFER_HANDLE handle,uint32_t len)
+{
+    int i=0;
+    for (i=0; i<APP_REC_QUEUING_DEPTH; i++)
+    {
+        if (rec_buf_queue[i].usbReadHandle == handle)
+        {
+            rec_buf_queue[i].isDataReady = 1;
+			rec_buf_queue[i].isUsed = 0;
+			rec_buf_queue[i].dataLen = len;
             break;
         }
     }
@@ -505,9 +869,10 @@ void APP_USBDeviceAudioEventHandler(USB_DEVICE_AUDIO_INDEX iAudio,
                 /* We have received a request from USB host to change the Interface-
                    Alternate setting.*/
                 interfaceInfo = (USB_DEVICE_AUDIO_EVENT_DATA_INTERFACE_SETTING_CHANGED *)pData;
-                appData.usbInterface = interfaceInfo->interfaceAlternateSetting; 
+                appData.usbInterface = interfaceInfo->interfaceNumber; 
+				appData.usbInterface_alt = interfaceInfo->interfaceAlternateSetting;
                         
-                debug_log("audio interface setted %d\r\n",interfaceInfo->interfaceAlternateSetting);
+                debug_log("audio interface %d setted %d\r\n",interfaceInfo->interfaceNumber, interfaceInfo->interfaceAlternateSetting);
             }
             break;
 
@@ -515,13 +880,19 @@ void APP_USBDeviceAudioEventHandler(USB_DEVICE_AUDIO_INDEX iAudio,
             {
                 //Now send this audio frame to Audio Codec for Playback.
                 readEventData = (USB_DEVICE_AUDIO_EVENT_DATA_READ_COMPLETE *)pData;
-                APP_SetUSBReadBufferReady(readEventData->handle);
+				
+                APP_SetUSBReadBufferReady(readEventData->handle,readEventData->length);
                
             }
             break;
 
             case USB_DEVICE_AUDIO_EVENT_WRITE_COMPLETE:
             {
+				readEventData = (USB_DEVICE_AUDIO_EVENT_DATA_READ_COMPLETE *)pData;
+				
+				APP_SetUSBWrBufferReady(readEventData->handle,readEventData->length);
+
+			
             }
             break;
             
@@ -680,6 +1051,7 @@ void APP_USBDeviceEventHandler(USB_DEVICE_EVENT event,
      // we check dma buff underrun here
      // overrun check will be done in  copy2dma_buff
      static unsigned int led_cnt= 0;
+	 //static unsigned int feed_cnt= 0;
 
 
 
@@ -696,7 +1068,11 @@ void APP_USBDeviceEventHandler(USB_DEVICE_EVENT event,
 		 if(led_cnt % 1000 == 0 && (appData.dmaBuffState != PLAY_DMA_BUF_UNDER_RUN) )
 		 	LED1_Toggle();
 
+
+		 
+
 		 led_cnt++;
+		 //feed_cnt++;
 
 		 
 	 }
diff --git a/app.h b/app.h
index f284c08..b5d9eec 100644
--- a/app.h
+++ b/app.h
@@ -21,6 +21,10 @@
 #ifndef APP_H
 #define APP_H
 
+#include "configuration.h"
+#include "definitions.h"
+
+
 // *****************************************************************************
 // *****************************************************************************
 // Section: Included Files
@@ -54,6 +58,14 @@ typedef enum
 
 } APP_STATES;
 
+typedef enum{
+	APP_RECORD_INIT = 0,
+	APP_RECORD_START_CHECK,
+	APP_RECORDING,
+	APP_RECORD_END
+
+}APP_RECORD_STATES;
+
 typedef enum
 {
 
@@ -69,12 +81,17 @@ typedef enum
 
     /* Application's state machine's initial state. */
     USB_AUDIO_INTERFACE_NON=0,
-    USB_AUDIO_INTERFACE_PLAYING,
-    USB_AUDIO_INTERFACE_CAPTURE,
+    USB_AUDIO_INTERFACE_PLAYING = 1,
+    USB_AUDIO_INTERFACE_CAPTURE = 2,
 
 } USB_AUDIO_INTERFACE_SETTING;
 
 
+
+
+
+
+
 void APP_Initialize ( void );
 void APP_Tasks ( void );
 void usb_open(void );
diff --git a/config/apb_sam_e54_ult_wm8904_ssc_sdmmc/configuration.h b/config/apb_sam_e54_ult_wm8904_ssc_sdmmc/configuration.h
new file mode 100644
index 0000000..0fd5ea3
--- /dev/null
+++ b/config/apb_sam_e54_ult_wm8904_ssc_sdmmc/configuration.h
@@ -0,0 +1,194 @@
+/*******************************************************************************
+  System Configuration Header
+
+  File Name:
+    configuration.h
+
+  Summary:
+    Build-time configuration header for the system defined by this project.
+
+  Description:
+    An MPLAB Project may have multiple configurations.  This file defines the
+    build-time options for a single configuration.
+
+  Remarks:
+    This configuration header must not define any prototypes or data
+    definitions (or include any files that do).  It only provides macro
+    definitions for build-time configuration options
+
+*******************************************************************************/
+
+// DOM-IGNORE-BEGIN
+/*******************************************************************************
+* Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
+*
+* Subject to your compliance with these terms, you may use Microchip software
+* and any derivatives exclusively with Microchip products. It is your
+* responsibility to comply with third party license terms applicable to your
+* use of third party software (including open source software) that may
+* accompany Microchip software.
+*
+* THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
+* EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
+* WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
+* PARTICULAR PURPOSE.
+*
+* IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
+* INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
+* WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
+* BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
+* FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
+* ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
+* THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
+*******************************************************************************/
+// DOM-IGNORE-END
+
+#ifndef CONFIGURATION_H
+#define CONFIGURATION_H
+
+// *****************************************************************************
+// *****************************************************************************
+// Section: Included Files
+// *****************************************************************************
+// *****************************************************************************
+/*  This section Includes other configuration headers necessary to completely
+    define this configuration.
+*/
+
+#include "user.h"
+#include "toolchain_specifics.h"
+
+// DOM-IGNORE-BEGIN
+#ifdef __cplusplus  // Provide C++ Compatibility
+
+extern "C" {
+
+#endif
+// DOM-IGNORE-END
+
+// *****************************************************************************
+// *****************************************************************************
+// Section: System Configuration
+// *****************************************************************************
+// *****************************************************************************
+
+
+
+// *****************************************************************************
+// *****************************************************************************
+// Section: System Service Configuration
+// *****************************************************************************
+// *****************************************************************************
+
+
+// *****************************************************************************
+// *****************************************************************************
+// Section: Driver Configuration
+// *****************************************************************************
+// *****************************************************************************
+
+
+// *****************************************************************************
+// *****************************************************************************
+// Section: Middleware & Other Library Configuration
+// *****************************************************************************
+// *****************************************************************************
+
+// #define USB_AUDIO_FEEDUP_ENABLE 1
+// #define AUDIO_IN_ENABLE 1
+// #define FEED_DEBUG
+
+
+#define USBD_AUDIO_MAX_FREQ 48000
+#define RECORD_FREQUENCE 48000
+#define RECORD_PERIOD_SIZE (RECORD_FREQUENCE/1000*2*2)
+
+
+#define USB_MAX_RX_SIZE                ( ( (USBD_AUDIO_MAX_FREQ * 2 * 2)/1000) *2 )
+
+
+/* Number of Endpoints used */
+#if USB_AUDIO_FEEDUP_ENABLE && AUDIO_IN_ENABLE
+#define DRV_USBFSV1_ENDPOINTS_NUMBER                        4
+#elif USB_AUDIO_FEEDUP_ENABLE || AUDIO_IN_ENABLE
+#define DRV_USBFSV1_ENDPOINTS_NUMBER                        3
+#else
+#define DRV_USBFSV1_ENDPOINTS_NUMBER                        2
+
+#endif
+
+/* The USB Device Layer will not initialize the USB Driver */
+#define USB_DEVICE_DRIVER_INITIALIZE_EXPLICIT
+
+/* Maximum device layer instances */
+#define USB_DEVICE_INSTANCES_NUMBER                         1
+
+/* EP0 size in bytes */
+#define USB_DEVICE_EP0_BUFFER_SIZE                          64
+
+/* Enable SOF Events */
+#define USB_DEVICE_SOF_EVENT_ENABLE
+
+
+
+
+
+
+/* Maximum instances of Audio function driver */
+#define USB_DEVICE_AUDIO_INSTANCES_NUMBER    1 
+
+
+/* Audio Transfer Queue Size for both read and
+   write. Applicable to all instances of the
+   function driver */
+#define USB_DEVICE_AUDIO_QUEUE_DEPTH_COMBINED (4+5)
+
+#ifdef AUDIO_IN_ENABLE
+/* No of Audio streaming interfaces */
+#define USB_DEVICE_AUDIO_MAX_STREAMING_INTERFACES   2
+#else
+#define USB_DEVICE_AUDIO_MAX_STREAMING_INTERFACES   1
+
+#endif
+
+/* No of alternate settings */
+#define USB_DEVICE_AUDIO_MAX_ALTERNATE_SETTING      2
+
+
+/*** USB Driver Configuration ***/
+
+/* Maximum USB driver instances */
+#define DRV_USBFSV1_INSTANCES_NUMBER                        1
+
+
+/* Enables Device Support */
+#define DRV_USBFSV1_DEVICE_SUPPORT                          true
+	
+/* Disable Host Support */
+#define DRV_USBFSV1_HOST_SUPPORT                            false
+
+/* Enable usage of Dual Bank */
+#define DRV_USBFSV1_DUAL_BANK_ENABLE                        false
+
+/* Alignment for buffers that are submitted to USB Driver*/ 
+#define USB_ALIGN  __ALIGNED(CACHE_LINE_SIZE)
+
+
+
+// *****************************************************************************
+// *****************************************************************************
+// Section: Application Configuration
+// *****************************************************************************
+// *****************************************************************************
+
+
+//DOM-IGNORE-BEGIN
+#ifdef __cplusplus
+}
+#endif
+//DOM-IGNORE-END
+
+#endif // CONFIGURATION_H
+/*******************************************************************************
+ End of File
+*/
diff --git a/config/apb_sam_e54_ult_wm8904_ssc_sdmmc/peripheral/dmac/plib_dmac.c b/config/apb_sam_e54_ult_wm8904_ssc_sdmmc/peripheral/dmac/plib_dmac.c
index 8268316..0df5b08 100644
--- a/config/apb_sam_e54_ult_wm8904_ssc_sdmmc/peripheral/dmac/plib_dmac.c
+++ b/config/apb_sam_e54_ult_wm8904_ssc_sdmmc/peripheral/dmac/plib_dmac.c
@@ -109,6 +109,17 @@ void DMAC_Initialize( void )
     /* Update the Priority Control register */
     DMAC_REGS->DMAC_PRICTRL0 = DMAC_PRICTRL0_LVLPRI0(1) | DMAC_PRICTRL0_RRLVLEN0_Msk | DMAC_PRICTRL0_LVLPRI1(1) | DMAC_PRICTRL0_RRLVLEN1_Msk | DMAC_PRICTRL0_LVLPRI2(1) | DMAC_PRICTRL0_RRLVLEN2_Msk | DMAC_PRICTRL0_LVLPRI3(1) | DMAC_PRICTRL0_RRLVLEN3_Msk;
 
+   /***************** Configure DMA channel 0 ********************/
+   DMAC_REGS->CHANNEL[0].DMAC_CHCTRLA = DMAC_CHCTRLA_TRIGACT(2) | DMAC_CHCTRLA_TRIGSRC(76) | DMAC_CHCTRLA_THRESHOLD(0) | DMAC_CHCTRLA_BURSTLEN(0) ;
+
+   descriptor_section[0].DMAC_BTCTRL = DMAC_BTCTRL_BLOCKACT_INT | DMAC_BTCTRL_BEATSIZE_HWORD | DMAC_BTCTRL_VALID_Msk | DMAC_BTCTRL_DSTINC_Msk ;
+
+   DMAC_REGS->CHANNEL[0].DMAC_CHPRILVL = DMAC_CHPRILVL_PRILVL(0);
+
+   dmacChannelObj[0].inUse = 1;
+
+   DMAC_REGS->CHANNEL[0].DMAC_CHINTENSET = (DMAC_CHINTENSET_TERR_Msk | DMAC_CHINTENSET_TCMPL_Msk);
+
 
    /***************** Configure DMA channel 1 ********************/
    DMAC_REGS->CHANNEL[1].DMAC_CHCTRLA = DMAC_CHCTRLA_TRIGACT(2) | DMAC_CHCTRLA_TRIGSRC(78) | DMAC_CHCTRLA_THRESHOLD(0) | DMAC_CHCTRLA_BURSTLEN(0) ;
@@ -124,7 +135,6 @@ void DMAC_Initialize( void )
     /* Enable the DMAC module & Priority Level x Enable */
     DMAC_REGS->DMAC_CTRL = DMAC_CTRL_DMAENABLE_Msk | DMAC_CTRL_LVLEN0_Msk | DMAC_CTRL_LVLEN1_Msk | DMAC_CTRL_LVLEN2_Msk | DMAC_CTRL_LVLEN3_Msk;
 }
-
 /*******************************************************************************
     This function schedules a DMA transfer on the specified DMA channel.
 ********************************************************************************/
diff --git a/config/apb_sam_e54_ult_wm8904_ssc_sdmmc/usb/src/usb_device_audio_v1_0.c b/config/apb_sam_e54_ult_wm8904_ssc_sdmmc/usb/src/usb_device_audio_v1_0.c
new file mode 100644
index 0000000..a6cee80
--- /dev/null
+++ b/config/apb_sam_e54_ult_wm8904_ssc_sdmmc/usb/src/usb_device_audio_v1_0.c
@@ -0,0 +1,1207 @@
+/*******************************************************************************
+ USB Audio Class Function Driver
+
+  Company:
+    Microchip Technology Inc.
+
+  File Name:
+    usb_device_audio.c
+
+  Summary:
+    USB audio class function driver.
+
+  Description:
+    USB audio class function driver.
+ *******************************************************************************/
+
+// DOM-IGNORE-BEGIN
+/*******************************************************************************
+* Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
+*
+* Subject to your compliance with these terms, you may use Microchip software
+* and any derivatives exclusively with Microchip products. It is your
+* responsibility to comply with third party license terms applicable to your
+* use of third party software (including open source software) that may
+* accompany Microchip software.
+*
+* THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
+* EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
+* WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
+* PARTICULAR PURPOSE.
+*
+* IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
+* INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
+* WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
+* BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
+* FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
+* ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
+* THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
+ *******************************************************************************/
+// DOM-IGNORE-END
+
+// *****************************************************************************
+// *****************************************************************************
+// Section: Included Files
+// *****************************************************************************
+// *****************************************************************************
+#include "usb/usb_device_audio_v1_0.h"
+#include "usb/src/usb_device_audio_local.h"
+
+
+#define debug_log(...) printf(__VA_ARGS__) 
+
+
+// *****************************************************************************
+// *****************************************************************************
+// Section: File Scope or Global Data Types
+// *****************************************************************************
+// *****************************************************************************
+
+
+
+// *****************************************************************************
+/* Function:
+    void _USB_DEVICE_AUDIO_IRPCancelAll(USB_DEVICE_AUDIO_INDEX iAudio )
+   Summary:
+    This function cancels all pending Read and Write requests placed to
+    USB Device Audio function driver.
+
+   Description:
+    This function cancels all pending Read and Write requests placed to
+    USB Device Audio function driver.
+   Precondition:
+    The function driver should have been configured.
+   Parameters:
+    iAudio - USB Device Audio Function Driver instance.
+
+   Returns:
+    None
+   Example:
+
+   Remarks:
+     None
+ */
+void _USB_DEVICE_AUDIO_IRPCancelAll(USB_DEVICE_AUDIO_INDEX iAudio );
+
+// *****************************************************************************
+/* AUDIO Device function driver structure
+
+  Summary:
+    Defines the function driver structure required for the device layer.
+
+  Description:
+    This data type defines the function driver structure required for the
+    device layer.
+
+  Remarks:
+    This structure is private to the USB stack.
+ */
+const USB_DEVICE_FUNCTION_DRIVER audioFunctionDriver =
+{
+
+    /* AUDIO init function */
+    .initializeByDescriptor             = &_USB_DEVICE_AUDIO_Initialize ,
+
+    /* AUDIO de-init function */
+    .deInitialize           = &_USB_DEVICE_AUDIO_Deinitialize ,
+
+    /* AUDIO set-up packet handler */
+    .controlTransferNotification     = &_USB_DEVICE_AUDIO_ControlTransferHandler,
+
+    /* AUDIO tasks function */
+    .tasks                  = NULL,
+
+    /* Audio Global Initialize function */
+    .globalInitialize = _USB_DEVICE_AUDIO_GlobalInitialize
+        
+};
+
+
+//******************************************************************************
+//******************************************************************************
+
+
+// ******************************************************************************
+/* Function:
+   void _USB_DEVICE_AUDIO_ControlTransferHandler
+   (
+       SYS_MODULE_INDEX iAudio,
+       USB_DEVICE_EVENT controlEvent,
+       USB_SETUP_PACKET * setupRequest
+   )
+
+  Summary:
+    Audio control transfer handler.
+
+  Description:
+    Audio control transfer handler. This is the callback the device layer calls
+    when there is a SETUP packet that is targeted to this particular instance
+    of Audio.
+
+  Returns:
+    This is a local function and should not be called directly by the
+    application.
+*/
+
+void _USB_DEVICE_AUDIO_ControlTransferHandler
+(
+    SYS_MODULE_INDEX iAudio,
+    USB_DEVICE_EVENT controlEvent,
+    USB_SETUP_PACKET * setupRequest
+)
+{
+    /* Obtain pointer to the Audio Instance that is being addressed*/
+    USB_DEVICE_AUDIO_INSTANCE *thisAudioInstance = &gUsbDeviceAudioInstance[iAudio];
+
+    /* check the validity of the function driver index */
+    if ( USB_DEVICE_AUDIO_INSTANCES_NUMBER <= iAudio )
+    {
+        /* invalid handle */
+        SYS_ASSERT (false, "invalid Audio Index");
+    }
+
+    /* Check Control Event  */
+    switch(controlEvent)
+    {
+        case USB_DEVICE_EVENT_CONTROL_TRANSFER_SETUP_REQUEST:
+            /* A new SETUP packet received from Host*/
+            _USB_DEVICE_AUDIO_SetupPacketHandler(iAudio,setupRequest);
+            break;
+
+        case USB_DEVICE_EVENT_CONTROL_TRANSFER_DATA_RECEIVED:
+            /* A Control Transfer data stage completed. Notify the application */
+            thisAudioInstance->appEventCallBack
+            (
+                iAudio,
+                USB_DEVICE_AUDIO_EVENT_CONTROL_TRANSFER_DATA_RECEIVED,
+                NULL,
+                0
+            );        
+            break;
+
+        case USB_DEVICE_EVENT_CONTROL_TRANSFER_DATA_SENT:
+            /* The Control Transfer data was sent the Host. Notify the application */
+            thisAudioInstance->appEventCallBack
+            (
+                iAudio,
+                USB_DEVICE_AUDIO_EVENT_CONTROL_TRANSFER_DATA_SENT,
+                NULL,
+                0
+            );
+            break;
+        default:
+            break;
+    }
+}/* End of function _USB_DEVICE_AUDIO_ControlTransferHandler */ 
+
+
+// ******************************************************************************
+/* Function:
+   void _USB_DEVICE_AUDIO_SetupPacketHandler
+   (
+       USB_DEVICE_AUDIO_INDEX iAudio ,
+       USB_SETUP_PACKET * setupPkt
+   )
+
+  Summary:
+    Handles a fresh SETUP packet received from Host.
+
+  Description:
+    Handles a fresh SETUP packet received from Host.
+
+  Returns:
+    This is a local function and should not be called directly by the
+    application.
+*/
+void _USB_DEVICE_AUDIO_SetupPacketHandler 
+(
+    USB_DEVICE_AUDIO_INDEX iAudio , 
+    USB_SETUP_PACKET * setupPkt
+)
+{
+    uint8_t audioControlInterfaceId;
+    uint8_t interfaceId;
+    uint8_t curAlternateSetting;
+    uint8_t prevAlternateSetting;
+    uint8_t streamIntfcIndex;
+    uint8_t noOfEndpoints;
+    USB_ENDPOINT ep; 
+    uint16_t maxPacketSize;
+    USB_DEVICE_HANDLE usbDeviceHandle;
+    USB_DEVICE_AUDIO_EVENT event;
+    USB_DEVICE_AUDIO_EVENT_DATA_INTERFACE_SETTING_CHANGED interfaceInfo;
+    USB_ERROR endpointEnableResult; 
+    USB_DEVICE_AUDIO_STREAMING_INTERFACE_ALTERNATE_SETTING *pCurAlternateStng;
+    USB_DEVICE_AUDIO_STREAMING_INTERFACE_ALTERNATE_SETTING *pPrevAlternateStng;
+    USB_DEVICE_AUDIO_STREAMING_INTERFACE *pStreamingInterface;
+
+    /* Obtain pointer to the Audio Instance that is being addressed*/
+    USB_DEVICE_AUDIO_INSTANCE* audioInstance = &gUsbDeviceAudioInstance[iAudio];
+
+    /* Obtain pointer to the Audio Interface collection*/
+    USB_DEVICE_AUDIO_INTERFACE_COLLECTION *curInfCollection =
+            &(audioInstance->infCollection);
+
+    /* Get the Device Layer handle */
+    usbDeviceHandle = gUsbDeviceAudioInstance[iAudio].devLayerHandle;
+    
+    /* Check if the request is a standard interface request*/
+    if (  (setupPkt->RequestType == USB_SETUP_REQUEST_TYPE_STANDARD)
+       && (setupPkt->Recipient == USB_SETUP_REQUEST_RECIPIENT_INTERFACE))
+
+    {
+        /* We have received Standard Set request */
+
+        /* Retrieve interface number from the Setup packet */
+        interfaceId = setupPkt->bIntfID;
+
+        /* Retrieve audio Control interface number*/
+        audioControlInterfaceId = curInfCollection->bControlInterfaceNum;
+        
+        switch(setupPkt->bRequest)
+        {
+            case USB_REQUEST_SET_INTERFACE:
+                curAlternateSetting = setupPkt->bAltID;
+                if (interfaceId == audioControlInterfaceId)
+                {
+                    /*SET INTERFACE command was received to Audio Control
+                      Interface */
+                    curInfCollection->bControlAltSetng = curAlternateSetting;
+                }
+                else
+                {
+                    /*An Audio Streaming interface has received SET INTERFACE
+                      command */
+                    streamIntfcIndex = interfaceId - audioControlInterfaceId - 1;
+
+					//if(streamIntfcIndex == 1){
+					//	debug_log("interface 2\r\n");
+					//}
+
+                    /* Get pointer to the current audio streaming interface */
+                    pStreamingInterface = &(curInfCollection->streamInf[streamIntfcIndex]);
+                    
+                    /* Get pointer to the Interface Alternate setting. */
+                    pCurAlternateStng
+                    = &(pStreamingInterface->alterntSetting[curAlternateSetting]);
+                    
+                    /* Find out how many endpoint are present for this Interface
+                     * Alternate setting */
+                    noOfEndpoints = pCurAlternateStng->numEndPoints;
+
+                    if ((noOfEndpoints) && (curAlternateSetting))
+                    {
+                        /* We have to enable the endpoint only if this alternate
+                         setting has at least one endpoint and the alternate
+                         setting is a non zero value */
+                        
+                        /*Retrieve endpoint size */
+                        ep = pCurAlternateStng->isoDataEp.epAddr;
+                        
+                        /* retrieve max packet size. */
+                        maxPacketSize
+                             = pCurAlternateStng->isoDataEp.epMaxPacketSize;
+
+                        /* Enable Isochronous Data Endpoint */
+                        endpointEnableResult = USB_DEVICE_EndpointEnable
+                        (
+                            usbDeviceHandle ,
+                            0,
+                            ep ,
+                            USB_TRANSFER_TYPE_ISOCHRONOUS ,
+                            maxPacketSize
+                        );
+                        if (endpointEnableResult != USB_ERROR_NONE)
+                        {
+                            debug_log("_USB_DEVICE_AUDIO_SetupPacketHandler():  Endpoint not Enabled");
+                        }
+
+                        if (noOfEndpoints == 2)
+                        {
+                            /* If number of Endpoints is Two, then it is sure
+                             * that this alternate setting reports a Isochronous
+                             * Sync Endpoint. Enable the Sync Endpoint. */
+
+
+	                        ep = pCurAlternateStng->isoSyncEp.epAddr;
+	                        maxPacketSize = pCurAlternateStng->isoSyncEp.epMaxPacketSize;
+
+	                        endpointEnableResult = USB_DEVICE_EndpointEnable (
+	                            usbDeviceHandle ,
+	                            0,
+	                            ep ,
+	                            USB_TRANSFER_TYPE_ISOCHRONOUS ,
+	                            maxPacketSize);
+							
+	                        if (endpointEnableResult != USB_ERROR_NONE)
+	                        {
+	                            debug_log("_USB_DEVICE_AUDIO_SetupPacketHandler(): sync Endpoint not Enabled %d\r\n",endpointEnableResult);
+	                        }
+							else{
+								//debug_log("_USB_DEVICE_AUDIO_SetupPacketHandler(): sync Endpoint Enabled\r\n");
+							}
+
+                        }
+
+                        /* Change Audio Instance object state to Initialized */ 
+                        pStreamingInterface->state
+                                    = USB_DEVICE_AUDIO_STRMNG_INTFC_INITIALIZED;
+                    }
+                    else /* alternateSetting  = 0 */ 
+                    {
+                        if (pStreamingInterface->state
+                                   == USB_DEVICE_AUDIO_STRMNG_INTFC_INITIALIZED)
+                        {
+                            /* Disable the Endpoint in the previous Active Alternate setting. */ 
+                            prevAlternateSetting = pStreamingInterface->activeSetting;
+
+                            /* Get a pointer to the previous alternate setting. */ 
+                            pPrevAlternateStng = &(pStreamingInterface->alterntSetting[prevAlternateSetting]);
+
+                            /* Get endpoint no of the previous alternate setting */ 
+                            ep = pPrevAlternateStng->isoDataEp.epAddr;
+                            
+                            USB_DEVICE_IRPCancelAll(usbDeviceHandle,  ep);
+
+                            /* Disable the Endpoint */ 
+                            USB_DEVICE_EndpointDisable(usbDeviceHandle ,ep);
+
+
+                            if (noOfEndpoints == 2)
+                            {
+                                /* If number of Endpoints is Two, then it is sure
+                                * that this alternate setting reports a Isochronous
+                                * Sync Endpoint. Disable the Sync Endpoint. */
+                            }
+                            curInfCollection->streamInf[streamIntfcIndex].state
+                                = USB_DEVICE_AUDIO_STRMNG_INTFC_NOT_INITIALIZED;
+                            
+                        }  
+                    }
+
+                    /* Remember the new alternate setting received */
+                    curInfCollection->streamInf[streamIntfcIndex].activeSetting 
+                    = curAlternateSetting;
+
+
+                    /* Notify application about the SET_INTERFACE request */
+                    interfaceInfo.interfaceNumber = interfaceId;
+                    interfaceInfo.interfaceAlternateSetting = curAlternateSetting;
+                    audioInstance->appEventCallBack
+                    (
+                        iAudio,
+                        USB_DEVICE_AUDIO_EVENT_INTERFACE_SETTING_CHANGED,
+                        &interfaceInfo,
+                        0
+                    );
+                }
+                /* Send an Acknowledgement to the Host */ 
+                USB_DEVICE_ControlStatus( usbDeviceHandle,
+                                USB_DEVICE_CONTROL_STATUS_OK);
+            break;
+            case USB_REQUEST_GET_INTERFACE:
+                if (interfaceId == audioControlInterfaceId)
+                {
+                    curAlternateSetting = curInfCollection->bControlAltSetng;
+                }
+                else
+                {
+                    streamIntfcIndex = interfaceId - audioControlInterfaceId - 1;
+                    curAlternateSetting
+                    = curInfCollection->streamInf[streamIntfcIndex].activeSetting;
+                }
+
+                USB_DEVICE_ControlSend( usbDeviceHandle,
+                        (void *)&curAlternateSetting, 1);
+                break;
+            default:
+                break;
+
+        }      
+    }/* End of if((setupPkt->bmRequestType == */ 
+    else if ( (setupPkt->RequestType == USB_SETUP_REQUEST_TYPE_CLASS )
+            && ((setupPkt->Recipient == USB_SETUP_REQUEST_RECIPIENT_INTERFACE) 
+            || (setupPkt->Recipient == USB_SETUP_REQUEST_RECIPIENT_ENDPOINT)))
+    {
+        /* We have received a Audio Class specific Interface request or
+           Audio Class specific Endpoint request */
+        switch (setupPkt->bRequest)
+        {
+            case USB_AUDIO_CS_SET_CUR:
+                event = USB_DEVICE_AUDIO_EVENT_CONTROL_SET_CUR;
+                break;
+            case USB_AUDIO_CS_GET_CUR:
+                event = USB_DEVICE_AUDIO_EVENT_CONTROL_GET_CUR;
+                break;
+            case USB_AUDIO_CS_SET_MIN:
+                event = USB_DEVICE_AUDIO_EVENT_CONTROL_SET_MIN;
+                break;
+            case USB_AUDIO_CS_GET_MIN:
+                event = USB_DEVICE_AUDIO_EVENT_CONTROL_GET_MIN;
+                break;
+            case USB_AUDIO_CS_SET_MAX:
+                event = USB_DEVICE_AUDIO_EVENT_CONTROL_SET_MAX;
+                break;
+            case USB_AUDIO_CS_GET_MAX:
+                event = USB_DEVICE_AUDIO_EVENT_CONTROL_GET_MAX;
+                break;
+            case USB_AUDIO_CS_SET_RES:
+                event = USB_DEVICE_AUDIO_EVENT_CONTROL_SET_RES;
+                break;
+            case USB_AUDIO_CS_GET_RES:
+                event = USB_DEVICE_AUDIO_EVENT_CONTROL_GET_RES;
+                break;
+            case USB_AUDIO_CS_SET_MEM:
+                event = USB_DEVICE_AUDIO_EVENT_ENTITY_SET_MEM;
+                break;
+            case USB_AUDIO_CS_GET_MEM:
+                event = USB_DEVICE_AUDIO_EVENT_ENTITY_GET_MEM;
+                break;
+            case USB_AUDIO_CS_GET_STAT:
+                event = USB_DEVICE_AUDIO_EVENT_ENTITY_GET_STAT;
+                break;
+            default:
+            /* Unknown request. Stall the request */
+                event = 0;
+                USB_DEVICE_ControlStatus(audioInstance->devLayerHandle,
+                                               USB_DEVICE_CONTROL_STATUS_ERROR);
+        }
+        if (( audioInstance->appEventCallBack) && (event))
+        {
+            /* Inform the application about the request */
+            /* The application needs to handle both EP and entity specific 
+               requests */
+           audioInstance->appEventCallBack ( iAudio, event, setupPkt, 0);
+        }        
+    }/* End of else if */ 
+}/* End of function _USB_DEVICE_AUDIO_SetupPacketHandler */ 
+
+
+//******************************************************************************
+
+
+// ******************************************************************************
+/* Function:
+    void _USB_DEVICE_AUDIO_GlobalInitialize ( void )
+
+  Summary:
+    This function initializes resources required common to all instances of AUDIO
+    function driver.
+
+  Description:
+    This function initializes resources common to all instances of AUDIO function
+    driver. This function is called by the USB Device layer during Initialization.
+
+  Remarks:
+    This is local function and should not be called directly by the application.
+*/
+void _USB_DEVICE_AUDIO_GlobalInitialize (void)
+{
+    OSAL_RESULT osal_err;
+
+    /* Create Mutex for CDC IRP objects if not created already */
+    if (gUSBDeviceAudioCommonDataObj.isMutexAudioIrpInitialized == false)
+    {
+        /* This means that mutexes where not created. Create them. */
+        osal_err = OSAL_MUTEX_Create(&gUSBDeviceAudioCommonDataObj.mutexAUDIOIRP);
+
+        if(osal_err != OSAL_RESULT_TRUE)
+        {
+            /*do not proceed lock was not created, let user know about error*/
+            return;
+        }
+
+         /* Set this flag so that global mutexes get allocated only once */
+         gUSBDeviceAudioCommonDataObj.isMutexAudioIrpInitialized = true;
+    }
+}
+
+// ******************************************************************************
+/* Function:
+    void _USB_DEVICE_AUDIO_Initialize 
+    (
+        SYS_MODULE_INDEX iAudio, 
+        DRV_HANDLE usbDeviceHandle,
+        void* funcDriverInit, 
+        uint8_t interfaceNumber, 
+        uint8_t alternateSetting,
+        uint8_t descriptorType, 
+        uint8_t * pDescriptor 
+    )
+
+  Summary:
+    This function is called by the device layer. It gets called multiple times as 
+    and when the USB device layer starts parsing the descriptors
+
+  Description:
+    This function is called by the device layer. It gets called multiple times as 
+    and when the USB device layer starts parsing the descriptors
+
+  Remarks:
+    This is local function and should not be called directly by the application.
+*/
+//******************************************************************************
+void _USB_DEVICE_AUDIO_Initialize 
+(
+    SYS_MODULE_INDEX iAudio, 
+    DRV_HANDLE usbDeviceHandle,
+    void* funcDriverInit, 
+    uint8_t interfaceNumber, 
+    uint8_t alternateSetting,
+    uint8_t descriptorType, 
+    uint8_t * pDescriptor 
+)
+{
+    /* Error */ 
+    USB_ERROR endpointEnableResult; 
+    
+    /* Pointer to Standard Endpoint Descriptor */
+    USB_ENDPOINT_DESCRIPTOR *pEPDesc;
+
+    /* Pointer to Standard Interface descriptor */
+    USB_INTERFACE_DESCRIPTOR *pStdInfDesc;
+    
+    /* Pointer to Class Specific Interface Descriptor */
+    USB_AUDIO_CS_AC_INTERFACE_HEADER_DESCRIPTOR *pCsInfDesc;
+
+    USB_DEVICE_AUDIO_INIT * audioInit;
+    uint8_t epAddressAndDirection;
+    uint16_t maxPacketSize;
+    uint8_t cnt;
+    uint8_t audioControlInterfaceId;
+    uint8_t strmIntrfcIndex;
+    USB_DEVICE_AUDIO_STREAMING_INTERFACE_ALTERNATE_SETTING *curAlternateStng;
+    USB_DEVICE_AUDIO_INSTANCE * audioInstance = &gUsbDeviceAudioInstance[iAudio];
+    USB_DEVICE_AUDIO_INTERFACE_COLLECTION *curInfCollection =
+            &(audioInstance->infCollection);
+    audioInit = ((USB_DEVICE_AUDIO_INIT *)funcDriverInit);
+    audioInstance->queueSizeRead = audioInit->queueSizeRead;
+    audioInstance->queueSizeWrite = audioInit->queueSizeWrite;
+    audioInstance->queueSizeStatusSend = audioInit->queueSizeStatusSend; 
+    audioInstance->currentQSizeRead = 0;
+    audioInstance->currentQSizeWrite = 0;
+    audioInstance->currentQSizeStatusSend = 0; 
+
+     /* Check the type of descriptor passed by device layer */
+    switch ( descriptorType )
+    { 
+        case USB_DESCRIPTOR_INTERFACE: 
+            /* Interface Descriptor Received */ 
+            
+            /* Save the device handle to the corresponding Audio Instance object. */ 
+            audioInstance->devLayerHandle = usbDeviceHandle;
+
+            /* Save the Audio Index to the corresponding Audio Instance object. */ 
+            audioInstance->audioIndex = iAudio;
+
+            pStdInfDesc = (USB_INTERFACE_DESCRIPTOR*) pDescriptor;
+
+            /* Check if it is USB audio interface descriptor */
+            if (pStdInfDesc->bInterfaceClass == USB_AUDIO_CLASS_CODE)
+            {
+                /* Check if it is an Audio Control Interface descriptor */
+                switch (pStdInfDesc->bInterfaceSubClass)
+                {
+                    case USB_AUDIO_AUDIOCONTROL:
+                        audioInstance->flags.allFlags = 0;
+                        /* The program control reached here means that the device
+                           layer has detected an Standard Audio Control interface 
+                           descriptor. Now we have to save all the fields present 
+                           in the Standard Audio Control interface descriptor to 
+                           the corresponding Audio Instance Object. */
+
+                        /*Save the Interface number to the corresponding Audio 
+                            Instance Object.*/
+                        curInfCollection->bControlInterfaceNum 
+                                    = pStdInfDesc->bInterfaceNumber;
+
+                        /* Save the no of endpoints present in the Audio Control 
+                        Interface. If there are endpoints present as part of AC 
+                        interface descriptor that must be an Interrupt endpoint.*/
+                        curInfCollection->isIntEpExists = pStdInfDesc->bNumEndPoints;
+                     break;
+                
+                
+                    case USB_AUDIO_AUDIOSTREAMING:
+                        /* We have received an Audio Streaming Interface descriptor. 
+                           Save the interface number to an array of Audio streaming 
+                           interfaces. For an audio function the interface numbers
+                           starts from Audio Control Interface ID.*/
+
+                        /* Save number of endpoints present in the streaming interface */ 
+                        audioControlInterfaceId 
+                                    = curInfCollection-> bControlInterfaceNum;
+                        /* Find out audio streaming interface array index. */ 
+                        strmIntrfcIndex = interfaceNumber-audioControlInterfaceId-1;
+
+                        /* Save no of endpoints present in the streaming interface */
+                        curAlternateStng 
+                        = &(audioInstance->infCollection.streamInf[strmIntrfcIndex].alterntSetting[alternateSetting]); 
+                        curAlternateStng->numEndPoints = pStdInfDesc->bNumEndPoints;
+                    break;
+                    default :
+                        break; 
+                }
+            }
+        break; /* End of case USB_DESCRIPTOR_INTERFACE: */ 
+    
+        /* Class Specific Audio Control Interface Descriptor. */ 
+        case USB_AUDIO_CS_INTERFACE:
+            /* If we have already received Audio Control Interface related
+            descriptors then ignore all further Class specific descriptors */ 
+            if (audioInstance->flags.audioControlInterfaceReady ==  true)
+                return;
+            pCsInfDesc = (USB_AUDIO_CS_AC_INTERFACE_HEADER_DESCRIPTOR*) pDescriptor;
+
+            /* Check if this Class specific descriptor belongs to an AC Interface*/
+            if (interfaceNumber == audioInstance->infCollection.bControlInterfaceNum)
+            {
+                if  (USB_AUDIO_HEADER == pCsInfDesc->bDescriptorSubtype)
+                {
+                    SYS_ASSERT((pCsInfDesc->bInCollection != USB_DEVICE_AUDIO_MAX_STREAMING_INTERFACES ),
+                        "Maximum number of streaming interfaces defined does not match descriptor value");
+
+                    /* Save number of audio steaming interfaces */ 
+                    audioInstance->infCollection.numStreamingInf = pCsInfDesc->bInCollection;
+
+                    /* Save interface numbers of the all available audio streaming and Midi interfaces. */
+                    for (cnt = 0; cnt < USB_DEVICE_AUDIO_MAX_STREAMING_INTERFACES; cnt++ )
+                    {
+                        audioInstance->infCollection.streamInf[cnt].interfaceNum
+                            = *((uint8_t *)&(pCsInfDesc->bInCollection) + cnt + 1);
+                    }
+
+                    /* Save audio specification number */ 
+                    audioInstance->infCollection.bcdADC = pCsInfDesc->bcdADC;
+                    audioInstance->flags.audioControlInterfaceReady = true;
+                } /* End of "if  (USB_AUDIO_HEADER == pCsInfDesc->bDescriptorSubtype)" */
+            } /* End of "if (interfaceNumber == audioInstance[iAudio].infCollection.bControlInterfaceNum)" */
+        break; /* End of "case DEVICE_AUDIO_CS_INTERFACE" */
+
+        case USB_DESCRIPTOR_ENDPOINT:
+            /* We have received an Endpoint descriptor from device Layer*/
+            pEPDesc = ( USB_ENDPOINT_DESCRIPTOR* ) pDescriptor;
+            audioControlInterfaceId = audioInstance->infCollection.bControlInterfaceNum;
+            strmIntrfcIndex = interfaceNumber - audioControlInterfaceId - 1;
+       
+            /* Find out if this Endpoint belongs to Audio Control or Audio 
+               Streaming interface */ 
+            if (interfaceNumber == audioInstance->infCollection.bControlInterfaceNum)
+            {
+                /* This Endpoint belongs Audio Control interface */ 
+
+                /* Check if the transfer type is interrupt and synchronization is
+                   set to none. */ 
+                   if ((pEPDesc->transferType == USB_TRANSFER_TYPE_INTERRUPT) 
+                      && (pEPDesc->syncType == USB_SYNCH_TYPE_NO_SYNCH))
+                   {
+                       /* Save the ep address */
+                       audioInstance->infCollection.intEp.epAddr = pEPDesc->bEndpointAddress;
+
+                       /* Save Max Packet Size */ 
+                       audioInstance->infCollection.intEp.epMaxPacketSize = pEPDesc->wMaxPacketSize; 
+
+                       /* Set the flag to true */ 	
+                       audioInstance->infCollection.isIntEpExists = true; 	
+
+                       /* Enable the endpoint */
+                       endpointEnableResult = USB_DEVICE_EndpointEnable(
+                                               usbDeviceHandle,
+                                               0,
+                                               pEPDesc->bEndpointAddress,
+                                               pEPDesc->transferType,
+                                               pEPDesc->wMaxPacketSize);
+
+                       if (endpointEnableResult == USB_ERROR_NONE)
+                       {
+                           audioInstance->infCollection.intEp.status = true; 
+                       }
+                       else
+                       {
+                           SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Audio function driver:  Endpoint not Enabled");
+                       }
+                   }
+                   else
+                   {
+                       SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Device Audio function driver: Invalid transfer type" ); 
+                   }
+            }
+            else if ((interfaceNumber == audioInstance->infCollection.streamInf[strmIntrfcIndex].interfaceNum))
+            {
+                /* This Endpoint belongs Audio Streaming interface */ 
+
+                /* Save the ep address */
+                epAddressAndDirection = pEPDesc->bEndpointAddress;
+
+                /* Save max packet size */
+                maxPacketSize = ( ( USB_ENDPOINT_DESCRIPTOR* ) pDescriptor )->wMaxPacketSize;
+       
+                if (pEPDesc->usageType == USB_USAGE_DATA_ENDPOINT)
+                {
+                    /* Save ep address to the data interface */
+                    audioInstance->infCollection.streamInf[strmIntrfcIndex].alterntSetting[alternateSetting].isoDataEp.epAddr = epAddressAndDirection;
+
+                    /* Save max packet size to the data interface */
+                    audioInstance->infCollection.streamInf[strmIntrfcIndex].alterntSetting[alternateSetting].isoDataEp.epMaxPacketSize = maxPacketSize;
+                }
+                else if (pEPDesc->usageType == USB_USAGE_FEEDBACK_ENDPOINT)
+                {
+                    /* Save ep address to the Sync interface */
+                    audioInstance->infCollection.streamInf[strmIntrfcIndex].alterntSetting[alternateSetting].isoSyncEp.epAddr = epAddressAndDirection;
+
+                    /* Save max packet size to the Sync interface */
+                    audioInstance->infCollection.streamInf[strmIntrfcIndex].alterntSetting[alternateSetting].isoSyncEp.epMaxPacketSize = maxPacketSize;
+					debug_log("usb audio driver: found feedback EP, addr 0x%x, size %d\r\n",epAddressAndDirection,maxPacketSize);
+				}
+            }
+            break;
+
+        default:
+        break; 
+    }//end of switch ( descriptorType )
+}
+
+// *****************************************************************************
+// ******************************************************************************
+/* Function:
+    void _USB_DEVICE_AUDIO_Deinitialize ( SYS_MODULE_INDEX iAudio )
+
+  Summary:
+    This function is called by the device layer when Audio Device is detached 
+    from the Host. 
+
+  Description:
+    This function is called by the device layer when Audio Device is detached 
+    from the Host. 
+
+  Remarks:
+    This is local function and should not be called directly by the application.
+*/
+//******************************************************************************
+void _USB_DEVICE_AUDIO_Deinitialize ( SYS_MODULE_INDEX iAudio )
+{
+    /* Cancel all IRPs on the owned endpoints and then
+     * disable the endpoint */
+    
+    if(iAudio >= USB_DEVICE_AUDIO_INSTANCES_NUMBER)
+    {
+        SYS_ASSERT(false," Invalid instance");
+        return;
+    }
+   _USB_DEVICE_AUDIO_IRPCancelAll(iAudio);
+}
+
+
+
+
+
+
+//******************************************************************************
+// ******************************************************************************
+/* Function:
+    void _USB_DEVICE_AUDIO_TransferIRPCallBack ( USB_DEVICE_IRP * irp )
+
+  Summary:
+    This function is called by the USB driver when an IRP is completed. 
+
+  Description:
+    This function is called by the USB driver when an IRP is completed.
+
+  Remarks:
+    This is local function and should not be called directly by the application.
+*/
+//******************************************************************************
+
+void _USB_DEVICE_AUDIO_TransferIRPCallBack ( USB_DEVICE_IRP * irp )
+{
+    _USB_DEVICE_AUDIO_TransferCompleteCallback(irp); 
+}
+
+
+void _USB_DEVICE_AUDIO_TransferAbortPrevent(USB_DEVICE_IRP * irp)
+{
+    USB_DEVICE_AUDIO_EVENT_DATA_READ_COMPLETE readEventData;
+    USB_DEVICE_AUDIO_INSTANCE *thisAudioInstance;
+    USB_DEVICE_AUDIO_INDEX iAudio;
+    uint8_t cnt;
+    USB_DEVICE_AUDIO_IRP_DATA *audioIrpData;
+    USB_DEVICE_AUDIO_EVENT event;
+
+    /* Initialize Status */
+    readEventData.status = USB_DEVICE_AUDIO_RESULT_ERROR;
+    
+    /* The user data field of the IRP contains the array index of the Audio IRP
+     * in the lower 16 bits and the and the unique Identifier in the upper 16 bits.
+     * Mask the upper 16 bits to the Audio IRP index associated with this IRP */
+
+    cnt = (uint8_t)(irp->userData & 0xFFFF);
+
+    /* Get a pointer to the Audio IRP data */
+    audioIrpData = &gUSBDeviceAudioIrpData[cnt];
+
+    /* Retrieve Audio Instance Number */
+    iAudio = audioIrpData->iAudio;
+
+    /* Get a pointer to the Audio Instance */
+    thisAudioInstance = &gUsbDeviceAudioInstance[iAudio];
+
+     /* Populate the event handler for this transfer. This was stored in the
+      * userData field of the IRP when the IRP was submitted. */
+    readEventData.handle = ( USB_DEVICE_AUDIO_TRANSFER_HANDLE ) irp->userData;
+
+    /* Update the size written */
+    readEventData.length = irp->size;
+    
+    
+    /* Get transfer status */
+    if ((irp->status == USB_DEVICE_IRP_STATUS_COMPLETED) 
+        || (irp->status == USB_DEVICE_IRP_STATUS_COMPLETED_SHORT))
+    {
+        /* Transfer completed successfully */
+        readEventData.status = USB_DEVICE_AUDIO_RESULT_OK; 
+    }
+   
+    /* Update Interface Number */ 
+    readEventData.interfaceNum = audioIrpData->interfaceNum;
+
+    if (audioIrpData->direction == USB_DEVICE_AUDIO_READ)
+    {
+        event = USB_DEVICE_AUDIO_EVENT_READ_COMPLETE;
+        thisAudioInstance->currentQSizeRead--;
+
+    }
+    else
+    {
+        event = USB_DEVICE_AUDIO_EVENT_WRITE_COMPLETE;
+        thisAudioInstance->currentQSizeWrite--; 
+    }
+
+    /* Send an event to the application */ 
+    if ((thisAudioInstance->appEventCallBack)
+        && (readEventData.status == USB_DEVICE_AUDIO_RESULT_OK))
+    {
+        thisAudioInstance->appEventCallBack(iAudio,
+                                            event,
+                                            &readEventData,
+                                            thisAudioInstance->userData);
+    }
+}
+void _USB_DEVICE_AUDIO_TransferAbortAllow(USB_DEVICE_IRP * irp)
+{
+    USB_DEVICE_AUDIO_EVENT_DATA_READ_COMPLETE readEventData;
+    USB_DEVICE_AUDIO_INSTANCE *thisAudioInstance;
+    USB_DEVICE_AUDIO_INDEX iAudio;
+    uint8_t cnt;
+    USB_DEVICE_AUDIO_IRP_DATA *audioIrpData;
+    USB_DEVICE_AUDIO_EVENT event;
+
+    /* Initialize Status */
+    readEventData.status = USB_DEVICE_AUDIO_RESULT_ERROR;
+    
+    /* The user data field of the IRP contains the array index of the Audio IRP
+     * in the lower 16 bits and the and the unique Identifier in the upper 16 bits.
+     * Mask the upper 16 bits to the Audio IRP index associated with this IRP */
+
+    cnt = (uint8_t)(irp->userData & 0xFFFF);
+
+    /* Get a pointer to the Audio IRP data */
+    audioIrpData = &gUSBDeviceAudioIrpData[cnt];
+
+    /* Retrieve Audio Instance Number */
+    iAudio = audioIrpData->iAudio;
+
+    /* Get a pointer to the Audio Instance */
+    thisAudioInstance = &gUsbDeviceAudioInstance[iAudio];
+
+     /* Populate the event handler for this transfer. This was stored in the
+      * userData field of the IRP when the IRP was submitted. */
+    readEventData.handle = ( USB_DEVICE_AUDIO_TRANSFER_HANDLE ) irp->userData;
+
+    /* Update the size written */
+    readEventData.length = irp->size;
+    
+    
+    /* Get transfer status */
+    if ((irp->status == USB_DEVICE_IRP_STATUS_COMPLETED) 
+        || (irp->status == USB_DEVICE_IRP_STATUS_COMPLETED_SHORT))
+    {
+        /* Transfer completed successfully */
+        readEventData.status = USB_DEVICE_AUDIO_RESULT_OK; 
+    }
+    else if (irp->status == USB_DEVICE_IRP_STATUS_ABORTED_ENDPOINT_HALT)
+    {
+        /* Transfer cancelled due to Endpoint Halt */
+        readEventData.status = USB_DEVICE_AUDIO_RESULT_ERROR_ENDPOINT_HALTED; 
+    }
+    else if (irp->status == USB_DEVICE_IRP_STATUS_TERMINATED_BY_HOST)
+    {
+        /* Transfer Cancelled by Host (Host sent a Clear feature )*/
+        readEventData.status = USB_DEVICE_AUDIO_RESULT_ERROR_TERMINATED_BY_HOST; 
+    }
+    else
+    {
+        /* Transfer was not completed successfully */
+        readEventData.status = USB_DEVICE_AUDIO_RESULT_ERROR; 
+    }
+
+    /* Update Interface Number */ 
+    readEventData.interfaceNum = audioIrpData->interfaceNum;
+
+    if (audioIrpData->direction == USB_DEVICE_AUDIO_READ)
+    {
+        event = USB_DEVICE_AUDIO_EVENT_READ_COMPLETE;
+        thisAudioInstance->currentQSizeRead--;
+
+    }
+    else
+    {
+        event = USB_DEVICE_AUDIO_EVENT_WRITE_COMPLETE;
+        thisAudioInstance->currentQSizeWrite--; 
+    }
+
+    /* Send an event to the application */ 
+    if (thisAudioInstance->appEventCallBack)
+    {
+        thisAudioInstance->appEventCallBack(iAudio,
+                                            event,
+                                            &readEventData,
+                                            thisAudioInstance->userData);
+    }
+    
+}
+
+// ******************************************************************************
+/* Function:
+    void _USB_DEVICE_AUDIO_StatusSendIRPCallBack ( USB_DEVICE_IRP * irp )
+
+  Summary:
+    This function is called by the USB driver when an Status IRP is completed. 
+
+  Description:
+    This function is called by the USB driver when an Status IRP is completed.
+
+  Remarks:
+    This is local function and should not be called directly by the application.
+*/
+//******************************************************************************
+
+void _USB_DEVICE_AUDIO_StatusSendIRPCallBack ( USB_DEVICE_IRP * irp )
+{
+    _USB_DEVICE_AUDIO_StatusSendCompleteCallback(irp);  
+}
+
+// ******************************************************************************
+/* Function:
+    void _USB_DEVICE_AUDIO_StatusSendAbortAllow(USB_DEVICE_IRP * irp)
+
+  Summary:
+    This function dispatches transfer complete events to the application. 
+
+  Description:
+    This function dispatches transfer complete events to the application. It 
+    dispatches all transfer complete events including transfer abort events. 
+
+  Remarks:
+    This is local function and should not be called directly by the application.
+*/
+//******************************************************************************
+void _USB_DEVICE_AUDIO_StatusSendAbortAllow(USB_DEVICE_IRP * irp)
+{
+    USB_DEVICE_AUDIO_EVENT_DATA_STATUS_SEND_COMPLETE statusSendEventData;
+    USB_DEVICE_AUDIO_INSTANCE *thisAudioInstance;
+    USB_DEVICE_AUDIO_INDEX iAudio;
+    USB_DEVICE_AUDIO_EVENT event;
+    
+    /* Initialize Status */
+    statusSendEventData.status = USB_DEVICE_AUDIO_RESULT_ERROR;
+    
+    /* The user data field of the IRP contains the Audio Instance Number in the 
+       lower 16 bits and the and the unique Identifier in the upper 16 bits.
+       Mask the upper 16 bits to the Audio IRP index associated with this IRP */
+
+    iAudio = (uint8_t)(irp->userData & 0xFFFF);
+    
+    /* Get a pointer to the Audio Instance */
+    thisAudioInstance = &gUsbDeviceAudioInstance[iAudio];
+    
+    /* Populate the event handler for this transfer. This was stored in the
+      * userData field of the IRP when the IRP was submitted. */
+    statusSendEventData.handle = ( USB_DEVICE_AUDIO_TRANSFER_HANDLE ) irp->userData;
+    
+      /* Get transfer status */
+    if ((irp->status == USB_DEVICE_IRP_STATUS_COMPLETED) 
+        || (irp->status == USB_DEVICE_IRP_STATUS_COMPLETED_SHORT))
+    {
+        /* Transfer completed successfully */
+        statusSendEventData.status = USB_DEVICE_AUDIO_RESULT_OK; 
+    }
+    else if (irp->status == USB_DEVICE_IRP_STATUS_ABORTED_ENDPOINT_HALT)
+    {
+        /* Transfer canceled due to Endpoint Halt */
+        statusSendEventData.status = USB_DEVICE_AUDIO_RESULT_ERROR_ENDPOINT_HALTED; 
+    }
+    else if (irp->status == USB_DEVICE_IRP_STATUS_TERMINATED_BY_HOST)
+    {
+        /* Transfer canceled by Host (Host sent a Clear feature )*/
+        statusSendEventData.status = USB_DEVICE_AUDIO_RESULT_ERROR_TERMINATED_BY_HOST; 
+    }
+    else
+    {
+        /* Transfer was not completed successfully */
+        statusSendEventData.status = USB_DEVICE_AUDIO_RESULT_ERROR; 
+    }
+    
+    event = USB_DEVICE_AUDIO_EVENT_STATUS_SEND_COMPLETE;
+    thisAudioInstance->currentQSizeStatusSend--;
+    
+    /* Send an event to the application */ 
+    if (thisAudioInstance->appEventCallBack)
+    {
+        thisAudioInstance->appEventCallBack(iAudio,
+                                            event,
+                                            &statusSendEventData,
+                                            thisAudioInstance->userData);
+    }
+}
+
+// ******************************************************************************
+/* Function:
+    void _USB_DEVICE_AUDIO_StatusSendAbortPrevent(USB_DEVICE_IRP * irp)
+
+  Summary:
+    This function dispatches transfer complete events to the application 
+    except transfer abort events. 
+
+  Description:
+    This function dispatches transfer complete events to the application. This 
+    function prevents transfer abort events going to application. 
+
+  Remarks:
+    This is local function and should not be called directly by the application.
+*/
+//******************************************************************************
+void _USB_DEVICE_AUDIO_StatusSendAbortPrevent(USB_DEVICE_IRP * irp)
+{
+    USB_DEVICE_AUDIO_EVENT_DATA_STATUS_SEND_COMPLETE statusSendEventData;
+    USB_DEVICE_AUDIO_INSTANCE *thisAudioInstance;
+    USB_DEVICE_AUDIO_INDEX iAudio;
+    USB_DEVICE_AUDIO_EVENT event;
+    
+    /* Initialize Status */
+    statusSendEventData.status = USB_DEVICE_AUDIO_RESULT_ERROR;
+    
+    /* The user data field of the IRP contains the Audio Instance Number in the 
+       lower 16 bits and the and the unique Identifier in the upper 16 bits.
+       Mask the upper 16 bits to the Audio IRP index associated with this IRP */
+
+    iAudio = (uint8_t)(irp->userData & 0xFFFF);
+    
+    /* Get a pointer to the Audio Instance */
+    thisAudioInstance = &gUsbDeviceAudioInstance[iAudio];
+    
+    /* Populate the event handler for this transfer. This was stored in the
+      * userData field of the IRP when the IRP was submitted. */
+    statusSendEventData.handle = ( USB_DEVICE_AUDIO_TRANSFER_HANDLE ) irp->userData;
+    
+      /* Get transfer status */
+    if ((irp->status == USB_DEVICE_IRP_STATUS_COMPLETED) 
+        || (irp->status == USB_DEVICE_IRP_STATUS_COMPLETED_SHORT))
+    {
+        /* Transfer completed successfully */
+        statusSendEventData.status = USB_DEVICE_AUDIO_RESULT_OK; 
+        
+        event = USB_DEVICE_AUDIO_EVENT_STATUS_SEND_COMPLETE;
+        thisAudioInstance->currentQSizeStatusSend--;
+    
+        /* Send an event to the application */ 
+        if (thisAudioInstance->appEventCallBack)
+        {
+            thisAudioInstance->appEventCallBack(iAudio,
+                                            event,
+                                            &statusSendEventData,
+                                            thisAudioInstance->userData);
+        }
+    }  
+}
+// ******************************************************************************
+/* Function:
+    void _USB_DEVICE_AUDIO_IRPCancelAll(USB_DEVICE_AUDIO_INDEX iAudio)
+
+  Summary:
+    This function cancels all pending IRPs on a Audio Function driver instance. 
+
+  Description:
+    This function cancels all pending IRPs on a Audio Function driver instance. 
+
+  Remarks:
+    This is local function and should not be called directly by the application.
+*/
+//******************************************************************************
+void _USB_DEVICE_AUDIO_IRPCancelAll(USB_DEVICE_AUDIO_INDEX iAudio)
+{
+    USB_DEVICE_AUDIO_INSTANCE * thisAudioInstance = &gUsbDeviceAudioInstance[iAudio];
+    uint8_t noOfStreamingInterface; 
+    uint8_t count;
+    uint8_t activeInterfaceSetting;
+    USB_DEVICE_AUDIO_STREAMING_INTERFACE* streamingInterface;
+    uint8_t endpointAddress;
+
+    /* Cancel All IRPs pending on Status Interrupt Endpoint */ 
+    if (thisAudioInstance->infCollection.isIntEpExists)
+    {
+        endpointAddress =  thisAudioInstance->infCollection.intEp.epAddr; 
+        
+        /* Cancel all IRPs on this Endpoint */
+        USB_DEVICE_IRPCancelAll(thisAudioInstance->devLayerHandle,  endpointAddress);
+    }
+    
+    /* Find out how many Streaming interfaces are supported by this Audio Instance*/
+    noOfStreamingInterface = thisAudioInstance->infCollection.numStreamingInf;
+
+    /* We have to cancel IRPs submitted for all of the streams */
+    for (count=0; count < noOfStreamingInterface; count++)
+    {
+        /* Get pointer current streaming interface */
+        streamingInterface = &thisAudioInstance->infCollection.streamInf[count];
+
+        /* Find out active alternate setting*/
+        activeInterfaceSetting = streamingInterface->activeSetting;
+
+        if (streamingInterface->alterntSetting[activeInterfaceSetting].numEndPoints)
+        {
+          /* Retrieve Isochronous Data Endpoint address */
+          endpointAddress = streamingInterface->alterntSetting[activeInterfaceSetting].isoDataEp.epAddr;
+
+          /* Double check if this not Endpoint 0*/
+          if (endpointAddress !=0)
+          {
+            /* Cancel all IRPs on this Endpoint */
+            USB_DEVICE_IRPCancelAll(gUsbDeviceAudioInstance[iAudio].devLayerHandle,  endpointAddress);
+          }
+          if (streamingInterface->alterntSetting[activeInterfaceSetting].numEndPoints == 2)
+          {
+              /* If there are Two Endpoints, second Endpoint is a Sync Endpoint */
+              endpointAddress = streamingInterface->alterntSetting[activeInterfaceSetting].isoSyncEp.epAddr;
+
+              /* Double if this not Endpoint 0*/
+              if (endpointAddress !=0)
+              {
+                /* Cancel all IRPs on this Endpoint */
+                USB_DEVICE_IRPCancelAll(gUsbDeviceAudioInstance[iAudio].devLayerHandle,  endpointAddress);
+              }
+          }
+        }
+        
+    }
+}
+
+
+// *****************************************************************************
+
+
+
+
+
+/*******************************************************************************
+ End of File
+ */
diff --git a/config/apb_sam_e54_ult_wm8904_ssc_sdmmc/usb_device_init_data.c b/config/apb_sam_e54_ult_wm8904_ssc_sdmmc/usb_device_init_data.c
new file mode 100644
index 0000000..3efd4d4
--- /dev/null
+++ b/config/apb_sam_e54_ult_wm8904_ssc_sdmmc/usb_device_init_data.c
@@ -0,0 +1,596 @@
+/*******************************************************************************
+  System Initialization File
+
+  File Name:
+    usb_device_init_data.c
+
+  Summary:
+    This file contains source code necessary to initialize the system.
+
+  Description:
+    This file contains source code necessary to initialize the system.  It
+    implements the "SYS_Initialize" function, defines the configuration bits,
+    and allocates any necessary global system resources,
+ *******************************************************************************/
+
+// DOM-IGNORE-BEGIN
+/*******************************************************************************
+* Copyright (C) 2018 Microchip Technology Inc. and its subsidiaries.
+*
+* Subject to your compliance with these terms, you may use Microchip software
+* and any derivatives exclusively with Microchip products. It is your
+* responsibility to comply with third party license terms applicable to your
+* use of third party software (including open source software) that may
+* accompany Microchip software.
+*
+* THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
+* EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
+* WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
+* PARTICULAR PURPOSE.
+*
+* IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
+* INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
+* WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
+* BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
+* FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
+* ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
+* THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
+ *******************************************************************************/
+// DOM-IGNORE-END
+
+// *****************************************************************************
+// *****************************************************************************
+// Section: Included Files
+// *****************************************************************************
+// *****************************************************************************
+
+#include "configuration.h"
+#include "definitions.h"
+/**************************************************
+ * USB Device Function Driver Init Data
+ **************************************************/
+	const USB_DEVICE_AUDIO_INIT audioInit0 =
+{
+	.queueSizeRead = 2,
+	.queueSizeWrite = 2
+};
+
+
+/**************************************************
+ * USB Device Layer Function Driver Registration 
+ * Table
+ **************************************************/
+const USB_DEVICE_FUNCTION_REGISTRATION_TABLE funcRegistrationTable[1] =
+{
+    
+	/* Audio Function 0 */
+    { 
+        .configurationValue = 1,    /* Configuration value */ 
+        .interfaceNumber = 0,       /* First interfaceNumber of this function */ 
+        .speed = USB_SPEED_HIGH|USB_SPEED_FULL,    /* Function Speed */ 
+        .numberOfInterfaces = 3,    /* Number of interfaces */
+        .funcDriverIndex = 0,  /* Index of Audio Function Driver */
+        .driver = (void*)USB_DEVICE_AUDIO_FUNCTION_DRIVER,    /* USB Audio function data exposed to device layer */
+        .funcDriverInit = (void*)&audioInit0    /* Function driver init data */
+    },
+
+
+};
+
+/*******************************************
+ * USB Device Layer Descriptors
+ *******************************************/
+/*******************************************
+ *  USB Device Descriptor 
+ *******************************************/
+
+const USB_DEVICE_DESCRIPTOR deviceDescriptor =
+{
+    0x12,                                                   // Size of this descriptor in bytes
+    USB_DESCRIPTOR_DEVICE,                                  // DEVICE descriptor type
+    0x0200,                                                 // USB Spec Release Number in BCD format
+    0x00,         // Class Code
+    0x00,         // Subclass code
+    0x00,         // Protocol code
+
+
+    USB_DEVICE_EP0_BUFFER_SIZE,                             // Max packet size for EP0, see configuration.h
+    0x04D8,                                                 // Vendor ID
+    0x00FE,                                                 // Product ID				
+    0x0100,                                                 // Device release number in BCD format
+    0x01,                                                   // Manufacturer string index
+    0x02,                                                   // Product string index
+	0x00,                                                   // Device serial number string index
+    0x01                                                    // Number of possible configurations
+};
+
+
+
+
+#define AUDIO_PACKET_SZE(frq)          (uint8_t)(((frq * 2 * 2)/1000) & 0xFF), \
+                                       (uint8_t)((((frq * 2 * 2)/1000) >> 8) & 0xFF)
+#define SAMPLE_FREQ(frq)               (uint8_t)(frq), (uint8_t)((frq >> 8)), (uint8_t)((frq >> 16))
+#define USB_ENDPOINT_TYPE_ISOCHRONOUS                 0x01
+#define USB_ENDPOINT_SYNC_TYPE_ASYNC                0x04
+#define AUDIO_FEED_UP_EP                     0x82
+#define AUDIO_IN_EP 0x83
+
+#define FEED_RATE 3
+
+#define AUDIO_FORMAT_TYPE_I                           0x01
+#define AUDIO_FORMAT_TYPE_III                         0x03
+#define AUDIO_CONTROL_MUTE                            0x0001
+
+
+#define MIC_IN_TERMINAL_ID                            5
+#define MIC_FU_ID                                     6
+#define MIC_OUT_TERMINAL_ID                           7
+
+
+#ifdef USB_AUDIO_FEEDUP_ENABLE 
+	#define FEEDUP_EP_SIZE 0x9
+#else
+	#define FEEDUP_EP_SIZE 0
+#endif
+
+#ifdef AUDIO_IN_ENABLE
+	#define AUDIO_RECORD_IN_SIZE 83
+#else
+	#define AUDIO_RECORD_IN_SIZE 0
+#endif
+
+
+/*******************************************
+ *  USB Full Speed Configuration Descriptor
+ *******************************************/
+const uint8_t fullSpeedConfigurationDescriptor[]=
+{
+	/* Configuration Descriptor */
+
+    0x09,                                                   // Size of this descriptor in bytes
+    USB_DESCRIPTOR_CONFIGURATION,                           // Descriptor Type
+    
+    USB_DEVICE_16bitTo8bitArrange((110+FEEDUP_EP_SIZE+AUDIO_RECORD_IN_SIZE)),       //(110 Bytes)Size of the Configuration descriptor
+#ifdef AUDIO_IN_ENABLE
+	3,
+#else
+    2,                                                      // Number of interfaces in this configuration
+#endif
+    0x01,                                                   // Index value of this configuration
+    0x00,                                                   // Configuration string index
+    USB_ATTRIBUTE_DEFAULT | USB_ATTRIBUTE_SELF_POWERED, // Attributes
+    100,
+	
+
+    /* Descriptor for Function 1 - Audio     */ 
+    
+    /* USB Speaker Standard Audio Control Interface Descriptor	*/
+    0x09,                            // Size of this descriptor in bytes (bLength)
+    USB_DESCRIPTOR_INTERFACE,        // INTERFACE descriptor type (bDescriptorType)
+    0,                               // Interface Number  (bInterfaceNumber)
+    0x00,                            // Alternate Setting Number (bAlternateSetting)
+    0x00,                            // Number of endpoints in this intf (bNumEndpoints)
+    USB_AUDIO_CLASS_CODE,            // Class code  (bInterfaceClass)
+    USB_AUDIO_AUDIOCONTROL,          // Subclass code (bInterfaceSubclass)
+    USB_AUDIO_PR_PROTOCOL_UNDEFINED, // Protocol code  (bInterfaceProtocol)
+    0x00,                            // Interface string index (iInterface)
+
+
+
+    /* USB Speaker Class-specific AC Interface Descriptor  */
+#ifdef AUDIO_IN_ENABLE
+	0x0a,
+#else
+    0x09,                           // Size of this descriptor in bytes (bLength)
+#endif
+    USB_AUDIO_CS_INTERFACE,         // CS_INTERFACE Descriptor Type (bDescriptorType)
+    USB_AUDIO_HEADER,               // HEADER descriptor subtype 	(bDescriptorSubtype)
+    0x00,0x01,                      /* Audio Device compliant to the USB Audio
+                                     * specification version 1.00 (bcdADC) */
+#ifdef AUDIO_IN_ENABLE
+	0x28+37,0x00,
+#else
+    0x28,0x00, 
+#endif
+    								/* Total number of bytes returned for the
+                                     * class-specific AudioControl interface
+                                     * descriptor. (wTotalLength). Includes the
+                                     * combined length of this descriptor header
+                                     * and all Unit and Terminal descriptors. */
+
+#ifdef AUDIO_IN_ENABLE
+	0x02,
+	0x01,
+	0x02,
+#else
+
+    1,                           /* The number of AudioStreaming interfaces
+                                     * in the Audio Interface Collection to which
+                                     * this AudioControl interface belongs
+                                     * (bInCollection) */
+    1,                           /* AudioStreaming interface 1 belongs to this
+                                     * AudioControl interface. (baInterfaceNr(1))*/
+#endif
+
+    /* USB Speaker Input Terminal Descriptor */
+    0x0C,                           // Size of the descriptor, in bytes (bLength)
+    USB_AUDIO_CS_INTERFACE,    		// CS_INTERFACE Descriptor Type (bDescriptorType)
+    USB_AUDIO_INPUT_TERMINAL,	    // INPUT_TERMINAL descriptor subtype (bDescriptorSubtype)
+    0x01,          				    // ID of this Terminal.(bTerminalID)
+    0x01,0x01,                      // (wTerminalType)
+    0x00,                           // No association (bAssocTerminal)
+    0x02,                           // Two Channels (bNrChannels)
+    0x03,0x00,                      // (wChannelConfig)
+    0x00,                           // Unused.(iChannelNames)
+    0x00,                           // Unused. (iTerminal)
+
+
+    /* USB Speaker Feature Unit Descriptor */
+    0x0A,                           // Size of the descriptor, in bytes (bLength)
+    USB_AUDIO_CS_INTERFACE,    		// CS_INTERFACE Descriptor Type (bDescriptorType)
+    USB_AUDIO_FEATURE_UNIT,         // FEATURE_UNIT  descriptor subtype (bDescriptorSubtype)
+    0x03,            				// ID of this Unit ( bUnitID  ).
+    0x01,          					// Input terminal is connected to this unit(bSourceID)
+    0x01,                           // (bControlSize) //was 0x03
+    0x01,                           // (bmaControls(0)) Controls for Master Channel
+    0x00,                           // (bmaControls(1)) Controls for Channel 1
+    0x00,                           // (bmaControls(2)) Controls for Channel 2
+    0x00,			    //  iFeature
+
+
+    /* USB Speaker Output Terminal Descriptor */
+    0x09,                           // Size of the descriptor, in bytes (bLength)
+    USB_AUDIO_CS_INTERFACE,    		// CS_INTERFACE Descriptor Type (bDescriptorType)
+    USB_AUDIO_OUTPUT_TERMINAL,      // OUTPUT_TERMINAL  descriptor subtype (bDescriptorSubtype)
+    0x02,          					// ID of this Terminal.(bTerminalID)
+    0x01,0x03,                      // (wTerminalType)See USB Audio Terminal Types.
+    0x00,                           // No association (bAssocTerminal)
+    0x03,             				// (bSourceID)
+    0x00,                           // Unused. (iTerminal)
+
+
+
+	
+#ifdef AUDIO_IN_ENABLE   
+		/* USB Microphone Input Terminal Descriptor */
+		0x0c, 	  /* bLength */
+		USB_AUDIO_CS_INTERFACE,	  /* bDescriptorType */
+		USB_AUDIO_INPUT_TERMINAL,		  /* bDescriptorSubtype */
+		MIC_IN_TERMINAL_ID, 				  /* bTerminal ID */
+		0x01,								  /* wTerminalType Generic Microphone	0x0201 */
+		0x02,
+		0x00,								  /* bAssocTerminal */
+		0x01,								  /* bNrChannels */
+		0x00,								  /* wChannelConfig 0x0000	Mono */
+		0x00,
+		0x00,								  /* iChannelNames */
+		0x00,								  /* iTerminal */
+		/* 12 byte*/
+	
+		/* USB Microphone Audio Feature Unit Descriptor */
+		0x09,								  /* bLength */
+		USB_AUDIO_CS_INTERFACE,	  /* bDescriptorType */
+		USB_AUDIO_FEATURE_UNIT, 		  /* bDescriptorSubtype */
+		MIC_FU_ID,							  /* bUnitID */
+		MIC_IN_TERMINAL_ID, 				  /* bSourceID */
+		0x01,								  /* bControlSize */
+		AUDIO_CONTROL_MUTE, 				  /* bmaControls(0) */
+		0x00,								  /* bmaControls(1) */
+		0x00,								  /* iTerminal */
+		/* 09 byte*/
+	
+		/*USB Microphone Output Terminal Descriptor */
+		0x09,								  /* bLength */
+		USB_AUDIO_CS_INTERFACE,	  /* bDescriptorType */
+		USB_AUDIO_OUTPUT_TERMINAL,		  /* bDescriptorSubtype */
+		MIC_OUT_TERMINAL_ID,				  /* bTerminalID */
+		0x01,								  /* wTerminalType USB STREAMING 0x0101*/
+		0x01,								  
+		0x00,								  /* bAssocTerminal */ 
+		MIC_FU_ID,							  /* bSourceID */
+		0x00,								  /* iTerminal */
+		/* 09 byte*/
+#endif /* AUDIO_IN_ENABLED   */
+
+
+
+
+
+    /* USB Speaker Standard AS Interface Descriptor (Alt. Set. 0) */
+    0x09,                            // Size of the descriptor, in bytes (bLength)
+    USB_DESCRIPTOR_INTERFACE,        // INTERFACE descriptor type (bDescriptorType)
+    1,	 // Interface Number  (bInterfaceNumber)
+    0x00,                            // Alternate Setting Number (bAlternateSetting)
+    0x00,                            // Number of endpoints in this intf (bNumEndpoints)
+    USB_AUDIO_CLASS_CODE,            // Class code  (bInterfaceClass)
+    USB_AUDIO_AUDIOSTREAMING,        // Subclass code (bInterfaceSubclass)
+    0x00,                            // Protocol code  (bInterfaceProtocol)
+    0x00,                            // Interface string index (iInterface)
+
+
+    /* USB Speaker Standard AS Interface Descriptor (Alt. Set. 1) */
+    0x09,                            // Size of the descriptor, in bytes (bLength)
+    USB_DESCRIPTOR_INTERFACE,        // INTERFACE descriptor type (bDescriptorType)
+    1,	 // Interface Number  (bInterfaceNumber)
+    0x01,                            // Alternate Setting Number (bAlternateSetting)
+
+#ifdef USB_AUDIO_FEEDUP_ENABLE
+	0x02,
+#else
+    0x01,                            // Number of endpoints in this intf (bNumEndpoints)
+#endif
+	
+    USB_AUDIO_CLASS_CODE,            // Class code  (bInterfaceClass)
+    USB_AUDIO_AUDIOSTREAMING,        // Subclass code (bInterfaceSubclass)
+    0x00,                            // Protocol code  (bInterfaceProtocol)
+    0x00,                            // Interface string index (iInterface)
+
+
+    /*  USB Speaker Class-specific AS General Interface Descriptor */
+    0x07,                           // Size of the descriptor, in bytes (bLength)
+    USB_AUDIO_CS_INTERFACE,     	// CS_INTERFACE Descriptor Type (bDescriptorType)
+    USB_AUDIO_AS_GENERAL,    		// GENERAL subtype (bDescriptorSubtype)
+    0x01,           				// Unit ID of the Output Terminal.(bTerminalLink)
+    0x01,                           // Interface delay. (bDelay)
+    0x01,0x00,                      // PCM Format (wFormatTag)
+
+
+    /*  USB Speaker Type 1 Format Type Descriptor */
+    0x0B,                           // Size of the descriptor, in bytes (bLength)
+    USB_AUDIO_CS_INTERFACE,     	// CS_INTERFACE Descriptor Type (bDescriptorType)
+    USB_AUDIO_FORMAT_TYPE ,         // FORMAT_TYPE subtype. (bDescriptorSubtype)
+    0x01,                           // FORMAT_TYPE_1. (bFormatType)
+    0x02,                           // two channel.(bNrChannels)
+    0x02,                           // 2 byte per audio subframe.(bSubFrameSize)
+    0x10,                           // 16 bits per sample.(bBitResolution)
+    0x01,                           // One frequency supported. (bSamFreqType)
+    0x80,0xBB,0x00,                 // Sampling Frequency = 48000 Hz(tSamFreq)
+
+
+    /*  USB Speaker Standard Endpoint Descriptor */
+    0x09,                            // Size of the descriptor, in bytes (bLength)
+    USB_DESCRIPTOR_ENDPOINT,         // ENDPOINT descriptor (bDescriptorType)
+    1 | USB_EP_DIRECTION_OUT,                            // Endpoint1:OUT (bEndpointAddress)
+#ifdef USB_AUDIO_FEEDUP_ENABLE
+  USB_ENDPOINT_TYPE_ISOCHRONOUS  | USB_ENDPOINT_SYNC_TYPE_ASYNC,        /* bmAttributes */
+  (uint8_t)(USB_MAX_RX_SIZE & 0xff),(uint8_t)((USB_MAX_RX_SIZE>>8)&0xff) ,	
+#else
+    0x09,                            /* ?(bmAttributes) Isochronous,Adaptive, data endpoint */
+    AUDIO_PACKET_SZE(USBD_AUDIO_MAX_FREQ),   // ?(wMaxPacketSize) //48 * 4
+#endif
+
+    0x01,                            // One packet per frame.(bInterval)
+    0x00,                            // Unused. (bRefresh)
+#ifdef USB_AUDIO_FEEDUP_ENABLE
+    AUDIO_FEED_UP_EP,                            // Unused. (bSynchAddress)
+#else
+	0x00,
+#endif
+
+
+    /* USB Speaker Class-specific Isoc. Audio Data Endpoint Descriptor*/
+    0x07,                            // Size of the descriptor, in bytes (bLength)
+    USB_AUDIO_CS_ENDPOINT,           // CS_ENDPOINT Descriptor Type (bDescriptorType)
+    USB_AUDIO_EP_GENERAL,            // GENERAL subtype. (bDescriptorSubtype)
+    0x00,                            /* No sampling frequency control, no pitch
+                                        control, no packet padding.(bmAttributes)*/
+    0x00,                            // Unused. (bLockDelayUnits)
+    0x00,0x00,                       // Unused. (wLockDelay)
+
+
+#ifdef USB_AUDIO_FEEDUP_ENABLE
+	  /* ##Endpoint 2 for feedback - Standard Descriptor */
+	  0x09,  							/* bLength */
+	  USB_DESCRIPTOR_ENDPOINT, 			  /* bDescriptorType */
+	  AUDIO_FEED_UP_EP, 				/* bEndpointAddress 2 in endpoint*/
+	  0x11, 							  /* bmAttributes */
+	  8,0,								  /* wMaxPacketSize in Bytes 3 */
+	  1,								  /* bInterval 1ms*/
+	  FEED_RATE,						/* bRefresh 1 ~ 9,host will get feedup evary FEED_RATE power of 2*/
+	  0x00, 							  /* bSynchAddress */
+	  /* 09 byte*/
+#endif
+
+	
+#ifdef AUDIO_IN_ENABLE
+	  /*----------------------------------------- 
+							 USB Microphone Audio Streaming Interface 
+												 -------------------------------------------------*/
+	  /* USB Microphone Standard AS Interface Descriptor - Audio Streaming Zero Bandwith */
+	  /* Interface 2, Alternate Setting 0											  */
+	  0x09,			/* bLength */
+	  USB_DESCRIPTOR_INTERFACE,		/* bDescriptorType */
+	  0x02, 								/* bInterfaceNumber */
+	  0x00, 								/* bAlternateSetting */
+	  0x00, 								/* bNumEndpoints */
+	  USB_AUDIO_CLASS_CODE,				/* bInterfaceClass */
+	  USB_AUDIO_AUDIOSTREAMING,		/* bInterfaceSubClass */
+	  0x00, 			/* bInterfaceProtocol */
+	  0x00, 								/* iInterface */
+	  /* 09 byte*/
+	  
+	  /* USB Microphone Standard AS Interface Descriptor - Audio Streaming Operational */
+	  /* Interface 2, Alternate Setting 1											*/
+	  0x09,			/* bLength */
+	  USB_DESCRIPTOR_INTERFACE,		/* bDescriptorType */
+	  0x02, 								/* bInterfaceNumber */
+	  0x01, 								/* bAlternateSetting */
+	  0x01, 								/* bNumEndpoints */
+	  USB_AUDIO_CLASS_CODE,				/* bInterfaceClass */
+	  USB_AUDIO_AUDIOSTREAMING,		/* bInterfaceSubClass */
+	  0x00, 			/* bInterfaceProtocol */
+	  0x00, 								/* iInterface */
+	  /* 09 byte*/
+	  
+	  /* USB Microphone Audio Streaming Class-Specific Interface Descriptor */
+	  0x07,	/* bLength */
+	  USB_AUDIO_CS_INTERFACE,		/* bDescriptorType */
+	  0x01,				/* bDescriptorSubtype */
+	  MIC_OUT_TERMINAL_ID,					/* bTerminalLink */
+	  0x01, 								/* bDelay */
+	  0x01, 								/* wFormatTag AUDIO_FORMAT_PCM	0x0001*/
+	  0x00,
+	  /* 07 byte*/
+	  
+	  /* USB Speaker Audio Type I Format Interface Descriptor */
+	  (0x08 + (3 /** SUPPORTED_FREQ_NBR*/)),	/* bLength */
+	  USB_AUDIO_CS_INTERFACE,		/* bDescriptorType */
+	  0x02,			/* bDescriptorSubtype */
+	  AUDIO_FORMAT_TYPE_I,					/* bFormatType */	
+	  0x02, 								/* bNrChannels */
+	  0x02, 								/* bSubFrameSize: 2 bytes */
+	  16,			 /* bBitResolution (effective bits per sample) */ 
+	  1, //SUPPORTED_FREQ_NBR,					 /* bSamFreqType number of supported frequencies */ 
+	  SAMPLE_FREQ(RECORD_FREQUENCE),	/* Audio sampling frequency coded on 3 bytes */
+	  /* 8 + 3*N byte*/
+	  
+	  /* USB Microphone Streaming Standard Endpoint Descriptor */
+	  0x09,	/* bLength */
+	  USB_DESCRIPTOR_ENDPOINT, 		/* bDescriptorType */
+	  AUDIO_IN_EP,							/* bEndpointAddress 1 In endpoint*/
+	  USB_ENDPOINT_TYPE_ISOCHRONOUS, //USB_ENDPOINT_TYPE_ISOCHRONOUS,								  /* bmAttributes: Isochrnous | Asynchronous */ 
+	  (uint8_t)(RECORD_PERIOD_SIZE & 0xff),(uint8_t)((RECORD_PERIOD_SIZE>>8)&0xff),
+	
+	  0x01, 								/* bInterval must be 1*/
+	  0x00, 								/* bRefresh must be 0 */
+	  0x00, 								/* bSynchAddress */
+	  /* 09 byte*/
+	 
+
+	    /* USB Speaker Class-specific Isoc. Audio Data Endpoint Descriptor*/
+	    0x07,                            // Size of the descriptor, in bytes (bLength)
+	    USB_AUDIO_CS_ENDPOINT,           // CS_ENDPOINT Descriptor Type (bDescriptorType)
+	    USB_AUDIO_EP_GENERAL,            // GENERAL subtype. (bDescriptorSubtype)
+	    0x00,                            /* No sampling frequency control, no pitch
+	                                        control, no packet padding.(bmAttributes)*/
+	    0x00,                            // Unused. (bLockDelayUnits)
+	    0x00,0x00,                       // Unused. (wLockDelay)
+
+	  
+#endif /* AUDIO_IN_ENABLED */  
+
+
+
+};
+
+/*******************************************
+ * Array of Full speed Configuration 
+ * descriptors
+ *******************************************/
+USB_DEVICE_CONFIGURATION_DESCRIPTORS_TABLE fullSpeedConfigDescSet[1] =
+{
+    fullSpeedConfigurationDescriptor
+};
+
+
+/**************************************
+ *  String descriptors.
+ *************************************/
+ /*******************************************
+ *  Language code string descriptor
+ *******************************************/
+    const struct
+    {
+        uint8_t bLength;
+        uint8_t bDscType;
+        uint16_t string[1];
+    }
+    sd000 =
+    {
+        sizeof(sd000),                                      // Size of this descriptor in bytes
+        USB_DESCRIPTOR_STRING,                              // STRING descriptor type
+        {0x0409}                                            // Language ID
+    };
+/*******************************************
+ *  Manufacturer string descriptor
+ *******************************************/
+    const struct
+    {
+        uint8_t bLength;                                    // Size of this descriptor in bytes
+        uint8_t bDscType;                                   // STRING descriptor type
+        uint16_t string[25];                                // String
+    }
+    sd001 =
+    {
+        sizeof(sd001),
+        USB_DESCRIPTOR_STRING,
+        {'M','i','c','r','o','c','h','i','p',' ','T','e','c','h','n','o','l','o','g','y',' ','I','n','c','.'}
+		
+    };
+
+/*******************************************
+ *  Product string descriptor
+ *******************************************/
+	const struct
+    {
+        uint8_t bLength;                                    // Size of this descriptor in bytes
+        uint8_t bDscType;                                   // STRING descriptor type
+        uint16_t string[27];                                // String
+    }
+    sd002 =
+    {
+        sizeof(sd002),
+        USB_DESCRIPTOR_STRING,
+		{'H','a','r','m','o','n','y',' ','U','S','B',' ','H','e','a','d','s','e','t',' ','E','x','a','m','p','l','e'}
+    }; 
+
+/***************************************
+ * Array of string descriptors
+ ***************************************/
+USB_DEVICE_STRING_DESCRIPTORS_TABLE stringDescriptors[3]=
+{
+    (const uint8_t *const)&sd000,
+    (const uint8_t *const)&sd001,
+    (const uint8_t *const)&sd002,
+};
+
+/*******************************************
+ * USB Device Layer Master Descriptor Table 
+ *******************************************/
+ 
+const USB_DEVICE_MASTER_DESCRIPTOR usbMasterDescriptor =
+{
+    &deviceDescriptor,                                      // Full speed descriptor
+    1,                                                      // Total number of full speed configurations available
+    fullSpeedConfigDescSet,                                 // Pointer to array of full speed configurations descriptors
+	NULL, 
+	0,
+	NULL,
+#ifdef 	AUDIO_IN_ENABLE
+	3,  													// Total number of string descriptors available.
+#else
+	2,
+#endif
+    stringDescriptors,                                      // Pointer to array of string descriptors.
+	NULL, 
+	NULL
+};
+
+
+/****************************************************
+ * USB Device Layer Initialization Data
+ ****************************************************/
+
+const USB_DEVICE_INIT usbDevInitData =
+{
+    /* Number of function drivers registered to this instance of the
+       USB device layer */
+    .registeredFuncCount = 1,
+	
+    /* Function driver table registered to this instance of the USB device layer*/
+    .registeredFunctions = (USB_DEVICE_FUNCTION_REGISTRATION_TABLE*)funcRegistrationTable,
+
+    /* Pointer to USB Descriptor structure */
+    .usbMasterDescriptor = (USB_DEVICE_MASTER_DESCRIPTOR*)&usbMasterDescriptor,
+
+    /* USB Device Speed */
+	.deviceSpeed =  USB_SPEED_FULL,
+	
+	/* Index of the USB Driver to be used by this Device Layer Instance */
+    .driverIndex = DRV_USBFSV1_INDEX_0,
+
+    /* Pointer to the USB Driver Functions. */
+    .usbDriverInterface = DRV_USBFSV1_DEVICE_INTERFACE,
+	
+};
+// </editor-fold>
diff --git a/main.c b/main.c
index 86121d4..40d94cd 100644
--- a/main.c
+++ b/main.c
@@ -42,10 +42,10 @@ extern void wm8904_init(void );
 
 
 
-static dmac_descriptor_registers_t pTxLinkedListDesc[2] __ALIGNED(16);
-DMA_BUF_DATA_TYPE wave_buf[1024] __ALIGNED(16);
-static unsigned int dma_cnt = 0;
-static unsigned int samples = 0;
+//static dmac_descriptor_registers_t pTxLinkedListDesc[2] __ALIGNED(16);
+//DMA_BUF_DATA_TYPE wave_buf[1024] __ALIGNED(16);
+//static unsigned int dma_cnt = 0;
+//static unsigned int samples = 0;
 
 
 /* in order to make multi dma descriptor work: 
@@ -80,7 +80,7 @@ unsigned int generate_sin(DMA_BUF_DATA_TYPE *buf, unsigned int frequency){
 //__IO  uint16_t test_pt;
 int main ( void )
 {
-    int i;
+ //   int i;
     
     //test_pt = (uint16_t)0x41000018;
     /* Initialize all modules */
diff --git a/wm8904.c b/wm8904.c
index 70227cc..2d8e6eb 100644
--- a/wm8904.c
+++ b/wm8904.c
@@ -102,7 +102,7 @@ void configure_codec(void)
 		printf("WM8904 not found!\n\r");
 		while(1);
 	}
-    printf("wm8904 access OK\r\n");
+    
 
 	wm8904_write_register(WM8904_BIAS_CONTROL_0, WM8904_ISEL_HP_BIAS);
 	wm8904_write_register(WM8904_VMID_CONTROL_0, WM8904_VMID_BUF_ENA |
@@ -178,7 +178,33 @@ void configure_codec(void)
 	wm8904_write_register(WM8904_ANALOGUE_HP_0, 
 						WM8904_HPL_RMV_SHORT | WM8904_HPL_ENA_OUTP | WM8904_HPL_ENA_DLY | WM8904_HPL_ENA | 
 						WM8904_HPR_RMV_SHORT | WM8904_HPR_ENA_OUTP | WM8904_HPR_ENA_DLY | WM8904_HPR_ENA);
-	wm8904_write_register(WM8904_ANALOGUE_OUT1_LEFT, WM8904_HPOUT_VU | WM8904_HPOUTL_VOL(0x39));
-	wm8904_write_register(WM8904_ANALOGUE_OUT1_RIGHT, WM8904_HPOUT_VU | WM8904_HPOUTR_VOL(0x39));
+	wm8904_write_register(WM8904_ANALOGUE_OUT1_LEFT, WM8904_HPOUTL_MUTE |  WM8904_HPOUT_VU | WM8904_HPOUTL_VOL(WM8904_HP_VOL_1DB));
+	wm8904_write_register(WM8904_ANALOGUE_OUT1_RIGHT, WM8904_HPOUTR_MUTE |  WM8904_HPOUT_VU | WM8904_HPOUTR_VOL(WM8904_HP_VOL_1DB));
 	delay_ms(100);
+
+
+	printf("WM8904 configured\r\n");
+}
+
+
+void wm8904_hpout_mute(unsigned char state){
+//	uint16_t data = 0;
+
+	if(state == CODEC_HPOUT_MUTE_OFF){
+
+		//data = wm8904_read_register(WM8904_ANALOGUE_OUT1_LEFT);
+		//data &= (~WM8904_HPOUT_VU);
+		//data &= (~WM8904_HPOUTL_MUTE);
+		//wm8904_write_register(WM8904_ANALOGUE_OUT1_LEFT, data);
+		//wm8904_write_register(WM8904_ANALOGUE_OUT1_RIGHT, data);	
+
+		wm8904_write_register(WM8904_ANALOGUE_OUT1_LEFT,   WM8904_HPOUT_VU | WM8904_HPOUTL_VOL(WM8904_HP_VOL_1DB));
+		wm8904_write_register(WM8904_ANALOGUE_OUT1_RIGHT,  WM8904_HPOUT_VU | WM8904_HPOUTR_VOL(WM8904_HP_VOL_1DB));
+	}
+	else{
+		wm8904_write_register(WM8904_ANALOGUE_OUT1_LEFT,  WM8904_HPOUTL_MUTE |  WM8904_HPOUT_VU | WM8904_HPOUTL_VOL(WM8904_HP_VOL_1DB));
+		wm8904_write_register(WM8904_ANALOGUE_OUT1_RIGHT, WM8904_HPOUTL_MUTE |  WM8904_HPOUT_VU | WM8904_HPOUTR_VOL(WM8904_HP_VOL_1DB));
+
+
+	}
 }
diff --git a/wm8904.h b/wm8904.h
index 4a1c454..c6ccef2 100644
--- a/wm8904.h
+++ b/wm8904.h
@@ -1250,7 +1250,30 @@
 
 
 
+typedef enum
+{
 
+	CODEC_HPOUT_MUTE_OFF = 0,
+	CODEC_HPOUT_MUTE_ON	
 
+} CODEC_MUTE_TYPE;
 
+
+typedef enum
+{
+
+	WM8904_HP_VOL_0DB = 0x39,
+	WM8904_HP_VOL_1DB = 0x3a,
+	WM8904_HP_VOL_2DB = 0x3b,
+	WM8904_HP_VOL_3DB = 0x3c,
+	WM8904_HP_VOL_4DB = 0x3d,
+	WM8904_HP_VOL_5DB = 0x3e,
+	WM8904_HP_VOL_6DB = 0x3e,
+
+} WM8904_HP_VOL_TYPE;
+
+
+
+void wm8904_hpout_mute(unsigned char state);
+void configure_codec(void);
 #endif
\ No newline at end of file
